diff -ruN timidity-0.2i/Makefile timidity-0.2i+tr+sf/Makefile
--- timidity-0.2i/Makefile	Sun May 26 18:26:46 1996
+++ timidity-0.2i+tr+sf/Makefile	Fri Mar 28 12:17:12 1997
@@ -25,7 +25,8 @@
 
 ########### Compiler and flags.
 CC = gcc
-DEBUGFLAGS = -Wall -O2
+#DEBUGFLAGS = -Wall -O2
+DEBUGFLAGS = -Wall -g
 
 ########### Install.
 INSTALL = /usr/bin/install
@@ -112,11 +113,13 @@
 #EXTRALIBS += -lgen
 
 # Select the Tcl/Tk interface
-SYSTEM += -DTCLTK -DWISH=\"wishx\" -DTKPROGPATH=\"$(TCL_DIR)/tkmidity.tcl\"
+SYSTEM += -DTCLTK -DTKPROGPATH=\"$(TCL_DIR)/tkmidity.tcl\"
 SYSEXTRAS += tk_c.c
 INST_TK = install.tk
 #EXTRAINCS +=
-#EXTRALIBS +=
+EXTRALIBS += -ltk -ltcl -L/usr/X11R6/lib -lX11
+# Linux user needs this.
+EXTRALIBS += -ldl
 
 ########### Now check out the options in config.h
 
@@ -144,7 +147,8 @@
 # Sources needed for every installation
 CSRCS = timidity.c common.c readmidi.c playmidi.c resample.c mix.c instrum.c \
         tables.c controls.c output.c filter.c \
-        wave_a.c raw_a.c dumb_c.c
+        wave_a.c raw_a.c dumb_c.c \
+	sndfont.c readsbk.c
 
 # Optional installation-specific sources
 OPTSRCS = hpux_a.c linux_a.c sun_a.c dec_a.c win_a.c \
@@ -162,8 +166,7 @@
 
 # Miscellaneous things to distribute in the source archive
 MAKEFILES = Makefile my my.pl
-BITMAPS = tkbitmaps/prev.xbm tkbitmaps/next.xbm tkbitmaps/play.xbm \
-	tkbitmaps/stop.xbm tkbitmaps/pause.xbm tkbitmaps/quit.xbm \
+BITMAPS = $(BITMAPF) \
 	BITMAPS/back.xbm BITMAPS/fwd.xbm BITMAPS/next.xbm BITMAPS/pause.xbm \
 	BITMAPS/prev.xbm BITMAPS/quit.xbm BITMAPS/restart.xbm \
 	BITMAPS/timidity.xbm
@@ -180,6 +183,7 @@
 ALLTCLF = $(TCLF) tclIndex
 BITMAPF = tkbitmaps/prev.xbm tkbitmaps/next.xbm tkbitmaps/play.xbm \
 	tkbitmaps/stop.xbm tkbitmaps/pause.xbm tkbitmaps/quit.xbm \
+	tkbitmaps/back.xbm tkbitmaps/fwrd.xbm \
 	BITMAPS/timidity.xbm
 
 MANPAGES = timidity.1
diff -ruN timidity-0.2i/README.sf timidity-0.2i+tr+sf/README.sf
--- timidity-0.2i/README.sf	Thu Jan  1 09:00:00 1970
+++ timidity-0.2i+tr+sf/README.sf	Wed Apr  2 21:20:22 1997
@@ -0,0 +1,70 @@
+================================================================
+	** Timidity SoundFont Extension **
+
+	    written by Takashi Iwai
+		<iwai@dragon.mm.t.u-tokyo.ac.jp>
+		<http://bahamut.mm.t.u-tokyo.ac.jp/~iwai/>
+
+	patch level 1: April 2, 1997
+================================================================
+
+* WHAT'S THIS?
+
+This is an extension to use samples in SoundFont files with
+timidity-0.2i.  You can employ both SoundFont file together with
+ordinary GUS patch files.  Both SBK and SF2 formats are supported.
+
+
+* USAGE
+
+Two commands are newly added in configuration.
+
+To specify the SoundFont file to be used, just add a line in config
+file like:
+
+	 soundfont sffile [order=number]
+
+The first parameter is the file name to be loaded.  The file itself
+is stored once after reading all configurations, then converted to
+the internal records except wave sample data.
+
+The optional argument specifies the order of searching.
+'order=0' means to search the SoundFont file at first, then search
+the GUS patches if the appropriate sample is not found.
+'order=1' means to search the SoundFont file after GUS patches.
+
+Another command 'font' is supplied to control the behavior of sample
+selection.  If you don't want to use some samples in the SoundFont
+file, specify the sample via 'exclude' sub-command.
+
+	font exclude bank [preset [keynote]]
+
+The first parameter is MIDI bank number of the sample to be removed.
+The optional second parameter is MIDI program number of the sample.
+For drum samples, specify 128 as bank, and drumset number as preset,
+and keynote number for the drum sample.
+
+You can change the order of individual sample (or bank) via "order"
+sub-command.
+
+	font order number bank [preset [keynote]]
+
+The first parameter is the order number (zero or one) to be changed,
+and the sequent parameters are as well as in exclude command above.
+
+
+* BUGS & TODO'S
+
+- noises on some bass drum samples
+- support of modulation envelope
+- support of cut off / resonance
+- support of chorus / reverb
+
+
+* CHANGES
+
+- pl.1
+	+ fix volume envelope calcuation
+	+ add font command
+	+ fix font-exclude control
+
diff -ruN timidity-0.2i/README.tk timidity-0.2i+tr+sf/README.tk
--- timidity-0.2i/README.tk	Tue May 21 00:00:18 1996
+++ timidity-0.2i+tr+sf/README.tk	Fri Mar 21 17:41:44 1997
@@ -1,11 +1,4 @@
----------------------------------------------------------------------
-Note: These modifications are now integrated into the sources, so you
-don't need to patch them, just uncomment the appropriate lines in
-the Makefile.    ..tt
----------------------------------------------------------------------
-
-
-This is the README file of TkMidity Ver.1.3, Tcl/Tk interface for
+This is the README file of TkMidity Ver.1.5, Tcl/Tk interface for
 TiMidity MIDI Converter/Player.
 
 TkMidity realizes the Tk interface panel communicating with true
@@ -13,30 +6,24 @@
 window without Motif libraries.
 
 
+* WHAT'S NEW in 1.5
+
+- Trace window using timer callback
+- Forward/backward buttons
+- A couple of bug fixes..
+
+
 * CONTENTS
 
 This archive contains the following files:
 
 README.tk	- this file
-tkmidity.patch	- a small patch to timidity-0.2h including fixes for
-		  tiny bugs 
-tk_ctl.c	- a new source file for tk-interface
+tk_c.c		- tk-interface control source file
 tkmidity.ptcl	- main tcl/tk source to be preprocessed
 tkpanel.tcl	- main control panel tcl/tk script
 browser.tcl	- file browser
 misc.tcl	- miscellaneous subroutines
 tkbitmaps/*.xbm	- bitmap files for TkMidity
-tkmidity.ad	- (gray background) resources for TkMidity
-
-
-* INSTALLATION
-
-- Extract all files on timidity 0.2h source directory
-- Apply tkmidity.patch
-- Modify Makefile (especially check the wish program name in Makefile)
-- Just "make" it.
-- Install it by "make install".
-- Enjoy!
 
 
 * USAGE
@@ -53,9 +40,9 @@
 configuration also can be saved on the start-up file by Save Config
 menu.
 
-The version 1.3 supports File Open/Close menus, and direct keyboard
-control. You can append arbitrary files from file browser. The
-shortcut key actions are as follows:
+From ver.1.3, File Open/Close menues and direct keyboard
+controls are supported. You can append arbitrary files from file
+browser. The shortcut key actions are as follows:
 
 	[Enter]		: Start Playing
 	[Space]		: Pause / Start Again
@@ -63,51 +50,30 @@
 	[q]		: Quit TkMidity
 	[p] or [Left]	: Previous File
 	[n] or [Right]	: Next File
-	[v] or [Down]	: Volume Down (10%)
-	[V] or [Up]	: Volume Up (10%)
+	[v] or [Down]	: Volume Down (5%)
+	[V] or [Up]	: Volume Up (5%)
 	[F10]		: Menu Mode
 	[Alt]+[Any]	: Select Each Menu
 
+From this version (1.4), trace mode window is realized. You can see a
+funny movements of volume and panning of each channel if you specify
+the option flag in command line (see manual).
+
 
 * PROGRAM NOTES
 
-This version supports both Tcl7.4/Tk4.0 and TclX7.3/Tk3.6 with
-addinput. Unfortunately random function is omitted in the normal Tcl
-library, I wrote a simple hack to invoke bash from the tcl script.
-But this dirty trick should cause an overhead. If you know more smart
-solution, please teach me. 
-
-If you have only Tcl7.3 base wish (like included in Slackware 2.x),
-the extended Tcl (TclX) and addinput patch are required to handle i/o
-between tcl and timidity. Fortunately in the normal Linux distribution
-by Slackware, this patch is already included. If you don't have this
-patch, please get it via a-ftp, etc. Since Tcl7.4 base wish has
-another function to handle i/o, the patch above is not necessary.
-The original addinput patch can be obtained from:
-	ftp.neosoft.com:~ftp/pub/distrib
-or 
-	harbor.ecn.purdue.edu:~ftp/pub/tcl/extensions
+This version requires Tcl7.5/Tk4.1 libraries.  Unlike the older tk
+interface, timidity links the tcl/tk libraries on its binary, not
+using wish program.  Also, shared memory access must be permitted.
 
 
 * TROUBLE SHOOTING
 
-- The program says many RC_UNKNOWN ... and dies.
-
-Possibly, the trouble of communication between TiMidity and Tk
-interpreter. Please check the wish program name in your Makefile.
-The default is "wishx" (not "wish").
-
-Start the Tk panel directly from command line as:
-	% wishx -f /usr/local/lib/timidity/tkmidity.tcl
-The Tk window will appear and tell a words "NEXT" on console.
-Then you can start TiMidity successfully.
-
 - Tk panel appears, but "Pipe Broken" message pops up.
 
 This occurs when the non-existing file is selected to play. 
-The ver.1.3 script verifies the existence of the file before pass to
+The present script verifies the existence of the file before pass to
 TiMidity, but occasionally this could happen...
-
 
 		Takashi Iwai	<iwai@dragon.mm.t.u-tokyo.ac.jp>
 				<http://bahamut.mm.t.u-tokyo.ac.jp/~iwai/>
diff -ruN timidity-0.2i/gentxt.c timidity-0.2i+tr+sf/gentxt.c
--- timidity-0.2i/gentxt.c	Thu Jan  1 09:00:00 1970
+++ timidity-0.2i+tr+sf/gentxt.c	Mon Mar 24 21:32:00 1997
@@ -0,0 +1,158 @@
+/*----------------------------------------------------------------
+ * string <--> Emu parameter conversion
+ *----------------------------------------------------------------*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include "config.h"
+#include "sbk.h"
+#include "sflayer.h"
+
+
+static char *gentypestr[] = {
+	"startaddr",	/* 0 */
+	"endaddr",	/* 1 */
+	"startloop",	/* 2 */
+	"endloop",	/* 3 */
+	"startCoarse",	/* 4 */
+	"modLfoToPitch",	/* 5 */
+	"vibLfoToPitch",	/* 6 */
+	"modEnvToPitch",	/* 7 */
+	"initFilterFc",	/* 8 */
+	"initFilterQ",	/* 9 */
+	"modLfoToFilterFc",	/* 10 */
+	"modEnvToFilterFc",	/* 11 */
+	"endCoarse",	/* 12 */
+	"modLfoToVol",	/* 13 */
+	"unused1",	/* 14 */
+	"chorusEffect",	/* 15 */
+	"reverbEffect",	/* 16 */
+	"pan",	/* 17 */
+	"unused2",	/* 18 */
+	"unused3",	/* 19 */
+	"unused4",	/* 20 */
+	"delayModLfo",	/* 21 */
+	"freqModLfo",	/* 22 */
+	"delayVibLfo",	/* 23 */
+	"freqVibLfo",	/* 24 */
+	"delayModEnv",	/* 25 */
+	"attackModEnv",	/* 26 */
+	"holdModEnv",	/* 27 */
+	"decayModEnv",	/* 28 */
+	"sustModEnv",	/* 29 */
+	"relModEnv",	/* 30 */
+	"keyToModEnvHold",	/* 31 */
+	"keyToModEnvDecay",	/* 32 */
+	"delayVolEnv",	/* 33 */
+	"attackVolEnv",	/* 34 */
+	"holdVolEnv",	/* 35 */
+	"decayVolEnv",	/* 36 */
+	"sustVolEnv",	/* 37 */
+	"relVolEnv",	/* 38 */
+	"keyToVolEnvHold",	/* 39 */
+	"keyToVolEnvDecay",	/* 40 */
+	"instrument",	/* 41 */
+	"reserved1",	/* 42 */
+	"keyRange",	/* 43 */
+	"velRange",	/* 44 */
+	"startloopCoarse",	/* 45 */
+	"keynum",	/* 46 */
+	"velocity",	/* 47 */
+	"initAtten",	/* 48 */
+	"reserved2",	/* 49 */
+	"endloopCoarse",	/* 50 */
+	"coarseTune",	/* 51 */
+	"fineTune",	/* 52 */
+	"sampleID",	/* 53 */
+	"sampleModes",	/* 54 */
+	"initialPitch", /* 55 */
+	"scaleTuning",	/* 56 */
+	"exclusiveClass",	/* 57 */
+	"overrideRootKey",	/* 58 */
+	"unused5",	/* 59 */
+	"endOper",	/* 60 */
+};
+
+
+/*
+ */
+
+char *get_genstr(int type)
+{
+	if (type >= 0 && type <= 60)
+		return gentypestr[type];
+	else
+		return "UNKNOWN";
+}
+
+
+void sbk_to_text(char *text, int type, int val, SFInfo *sf)
+{
+	char *name;
+
+	name = get_genstr(type);
+	switch (type) {
+	case 43:
+	case 44:
+		sprintf(text, "%s %d:%d", name, val & 0xff, (val >> 8) & 0xff);
+		break;
+	case 41:
+		sprintf(text, "%s %d:[%s]", name, val, sf->insthdr[val].name);
+		break;
+	case 53:
+		sprintf(text, "%s %d:[%s]", name, val, sf->samplenames[val].name);
+		break;
+	default:
+		sprintf(text, "%s %d", name, val);
+		break;
+	}
+}
+
+/*
+ */
+
+char *gettag(char *line)
+{
+	static char *lastp;
+	char *p, *tag;
+
+	if (line)
+		lastp = line;
+
+	for (p = lastp; *p && isspace(*p); p++)
+		;
+
+	if (*p == 0)
+		return NULL;
+
+	if (*p == '[') {
+		p++;
+		tag = p;
+		for (; *p && *p != ']' && *p != '\n'; p++)
+			;
+	} else {
+		tag = p;
+		for (; *p && !isspace(*p); p++)
+			;
+	}
+	if (*p)
+		lastp = p + 1;
+	else
+		lastp = p;
+
+	*p = 0;
+	return tag;
+}
+
+int get_gentype(char *str)
+{
+	int k;
+	for (k = 0; k < PARM_SIZE; k++) {
+		if (strcmp(str, gentypestr[k]) == 0)
+			return k;
+	}
+	return -1;
+}
+
Binary files timidity-0.2i/gentxt.o and timidity-0.2i+tr+sf/gentxt.o differ
diff -ruN timidity-0.2i/instrum.c timidity-0.2i+tr+sf/instrum.c
--- timidity-0.2i/instrum.c	Mon May 20 22:15:10 1996
+++ timidity-0.2i+tr+sf/instrum.c	Thu Apr  3 18:23:22 1997
@@ -256,6 +256,7 @@
     }
   
   ip=safe_malloc(sizeof(Instrument));
+  ip->type = INST_GUS;
   ip->samples = tmp[198];
   ip->sample = safe_malloc(sizeof(Sample) * ip->samples);
   for (i=0; i<ip->samples; i++)
@@ -561,6 +562,7 @@
   return ip;
 }
 
+
 static int fill_bank(int dr, int b)
 {
   int i, errors=0;
@@ -602,7 +604,15 @@
 	      bank->tone[i].instrument=0;
 	      errors++;
 	    }
-	  else if (!(bank->tone[i].instrument=
+	  else {
+	    /* preload soundfont */
+	    if (dr)
+		    bank->tone[i].instrument = load_soundfont(0, 128, b, i);
+	    else
+		    bank->tone[i].instrument = load_soundfont(0, b, i, -1);
+	    /* load patch file */
+	    if (!bank->tone[i].instrument) {
+		  if (!(bank->tone[i].instrument=
 		     load_instrument(bank->tone[i].name, 
 				     (dr) ? 1 : 0,
 				     bank->tone[i].pan,
@@ -617,14 +627,23 @@
 				     bank->tone[i].strip_envelope :
 				     ((dr) ? 1 : -1),
 				     bank->tone[i].strip_tail )))
-	    {
-	      ctl->cmsg(CMSG_ERROR, VERB_NORMAL, 
-		   "Couldn't load instrument %s (%s %d, program %d)",
-		   bank->tone[i].name,
-		   (dr)? "drum set" : "tone bank", b, i);
-	      errors++;
+		    {
+		      /* no patch; search soundfont again */
+		      if (dr)
+			      bank->tone[i].instrument = load_soundfont(1, 128, b, i);
+		      else
+			      bank->tone[i].instrument = load_soundfont(1, b, i, -1);
+		      if (!bank->tone[i].instrument) {
+		      ctl->cmsg(CMSG_ERROR, VERB_NORMAL, 
+				"Couldn't load instrument %s (%s %d, program %d)",
+				bank->tone[i].name,
+				(dr)? "drum set" : "tone bank", b, i);
+		      errors++;
+		      }
+		    }
 	    }
 	}
+      }
     }
   return errors;
 }
diff -ruN timidity-0.2i/instrum.h timidity-0.2i+tr+sf/instrum.h
--- timidity-0.2i/instrum.h	Mon May 20 22:15:02 1996
+++ timidity-0.2i+tr+sf/instrum.h	Thu Apr  3 16:58:53 1997
@@ -25,6 +25,10 @@
   int32
     loop_start, loop_end, data_length,
     sample_rate, low_freq, high_freq, root_freq;
+
+  int8
+    root_tune, fine_tune;
+
   int32
     envelope_rate[6], envelope_offset[6];
   float
@@ -38,6 +42,8 @@
     modes;
   int8
     panning, note_to_use;
+  int16
+    scale_tuning;
 } Sample;
 
 /* Bits in modes: */
@@ -49,7 +55,11 @@
 #define MODES_SUSTAIN	(1<<5)
 #define MODES_ENVELOPE	(1<<6)
 
+#define INST_GUS	0
+#define INST_SF2	1
+
 typedef struct {
+  int type;
   int samples;
   Sample *sample;
 } Instrument;
@@ -68,6 +78,7 @@
   ToneBankElement tone[128];
 } ToneBank;
 
+extern char *sf_file;
 extern ToneBank *tonebank[], *drumset[];
 
 extern Instrument *default_instrument;
@@ -75,6 +86,7 @@
 extern int antialiasing_allowed;
 extern int fast_decay;
 extern int free_instruments_afterwards;
+extern int cutoff_allowed;
 
 #define SPECIAL_PROGRAM -1
 
@@ -82,3 +94,7 @@
 extern void free_instruments(void);
 extern int set_default_instrument(char *name);
 
+extern void init_soundfont(char *fname, int order);
+Instrument *load_soundfont(int order, int bank, int preset, int keynote);
+void exclude_soundfont(int bank, int preset, int keynote);
+void order_soundfont(int bank, int preset, int keynote, int order);
diff -ruN timidity-0.2i/misc.tcl timidity-0.2i+tr+sf/misc.tcl
--- timidity-0.2i/misc.tcl	Fri Mar 29 18:19:49 1996
+++ timidity-0.2i+tr+sf/misc.tcl	Mon Feb 17 16:46:11 1997
@@ -17,6 +17,27 @@
 }
 
 #
+# get root file name
+#
+proc retrieve-filename {path} {
+    set divs [split $path /]
+    return [lindex $divs [expr [llength $divs] - 1]]
+}
+
+
+#
+# sec to time string
+#
+proc sec2time {sec} {
+    if {$sec >= 0} {
+	return [format "%02d:%02d" [expr $sec / 60] [expr $sec % 60]]
+    } else {
+	set sec [expr -$sec]
+	return [format "-%02d:%02d" [expr $sec / 60] [expr $sec % 60]]
+    }
+}
+
+#
 # numeric binding:
 # only numerical key and some controls are available for input.
 #
@@ -200,21 +221,27 @@
 }
 
 #----------------------------------------------------------------
-# pseudo random without TclX using bash -- quick and dirty hack!!
+# pseudo random routine without TclX
 #----------------------------------------------------------------
 
 set pseudo_random [catch {random 1}]
+set pseudo_random_next -1
 proc my-random {max} {
-    global pseudo_random
+    global pseudo_random pseudo_random_next
     if {$pseudo_random} {
-	return [expr [exec bash -c {echo $RANDOM}] % $max]
+	set pseudo_random_next [expr $pseudo_random_next * 1103515245 + 12345]
+	return [expr ($pseudo_random_next/65536) % $max]
+	# Or, use bash's random routine instead...
+	# return [expr [exec bash -c {echo $RANDOM}] % $max]
     } else {
 	return [random $max]
     }
 }
 proc init-random {num} {
-    global pseudo_random
-    if {!$pseudo_random} {
+    global pseudo_random pseudo_random_next
+    if {$pseudo_random} {
+	set pseudo_random_next $num
+    } else {
 	random seed $num
     }
 }
diff -ruN timidity-0.2i/ncurs_c.c timidity-0.2i+tr+sf/ncurs_c.c
--- timidity-0.2i/ncurs_c.c	Tue May 21 06:27:35 1996
+++ timidity-0.2i+tr+sf/ncurs_c.c	Sun Sep  8 20:44:11 1996
@@ -26,7 +26,7 @@
 #include <unistd.h>
 #include <stdarg.h>
 
-#include <ncurses.h>
+#include <curses.h>
 
 #include "config.h"
 #include "common.h"
diff -ruN timidity-0.2i/playmidi.c timidity-0.2i+tr+sf/playmidi.c
--- timidity-0.2i/playmidi.c	Mon May 20 22:09:46 1996
+++ timidity-0.2i+tr+sf/playmidi.c	Fri Mar 28 14:30:30 1997
@@ -117,55 +117,6 @@
   reset_voices();
 }
 
-static void select_sample(int v, Instrument *ip)
-{
-  int32 f, cdiff, diff;
-  int s,i;
-  Sample *sp, *closest;
-
-  s=ip->samples;
-  sp=ip->sample;
-
-  if (s==1)
-    {
-      voice[v].sample=sp;
-      return;
-    }
-
-  f=voice[v].orig_frequency;
-  for (i=0; i<s; i++)
-    {
-      if (sp->low_freq <= f && sp->high_freq >= f)
-	{
-	  voice[v].sample=sp;
-	  return;
-	}
-      sp++;
-    }
-
-  /* 
-     No suitable sample found! We'll select the sample whose root
-     frequency is closest to the one we want. (Actually we should
-     probably convert the low, high, and root frequencies to MIDI note
-     values and compare those.) */
-
-  cdiff=0x7FFFFFFF;
-  closest=sp=ip->sample;
-  for(i=0; i<s; i++)
-    {
-      diff=sp->root_freq - f;
-      if (diff<0) diff=-diff;
-      if (diff<cdiff)
-	{
-	  cdiff=diff;
-	  closest=sp;
-	}
-      sp++;
-    }
-  voice[v].sample=closest;
-  return;
-}
-
 static void recompute_freq(int v)
 {
   int 
@@ -279,49 +230,74 @@
     }
 }
 
-static void start_note(MidiEvent *e, int i)
-{
-  Instrument *ip;
-  int j;
+static int find_voice(MidiEvent *e);
 
-  if (ISDRUMCHANNEL(e->channel))
-    {
-      if (!(ip=drumset[channel[e->channel].bank]->tone[e->a].instrument))
-	{
-	  if (!(ip=drumset[0]->tone[e->a].instrument))
-	    return; /* No instrument? Then we can't play. */
-	}
-      if (ip->samples != 1)
-	{
-	  ctl->cmsg(CMSG_WARNING, VERB_VERBOSE, 
-	       "Strange: percussion instrument with %d samples!", ip->samples);
+static int find_samples(MidiEvent *e, int *vlist)
+{
+	Instrument *ip;
+	Sample *sp, *closest;
+	int32 f, cdiff, diff;
+	int i, nv, note;
+
+	if (ISDRUMCHANNEL(e->channel)) {
+		if (!(ip=drumset[channel[e->channel].bank]->tone[e->a].instrument)) {
+			if (!(ip=drumset[0]->tone[e->a].instrument))
+				return 0; /* No instrument? Then we can't play. */
+		}
+		if (ip->type == INST_GUS && ip->samples != 1) {
+			ctl->cmsg(CMSG_WARNING, VERB_VERBOSE, 
+				  "Strange: percussion instrument with %d samples!", ip->samples);
+			return 0;
+		}
+	} else {
+		if (channel[e->channel].program==SPECIAL_PROGRAM)
+			ip=default_instrument;
+		else if (!(ip=tonebank[channel[e->channel].bank]->
+			   tone[channel[e->channel].program].instrument)) {
+			if (!(ip=tonebank[0]->tone[channel[e->channel].program].instrument))
+				return 0; /* No instrument? Then we can't play. */
+		}
 	}
 
-      if (ip->sample->note_to_use) /* Do we have a fixed pitch? */
-	voice[i].orig_frequency=freq_table[(int)(ip->sample->note_to_use)];
-      else
-	voice[i].orig_frequency=freq_table[e->a & 0x7F];
-      
-      /* drums are supposed to have only one sample */
-      voice[i].sample=ip->sample;
-    }
-  else
-    {
-      if (channel[e->channel].program==SPECIAL_PROGRAM)
-	ip=default_instrument;
-      else if (!(ip=tonebank[channel[e->channel].bank]->
-		 tone[channel[e->channel].program].instrument))
-	{
-	  if (!(ip=tonebank[0]->tone[channel[e->channel].program].instrument))
-	    return; /* No instrument? Then we can't play. */
+	if (ip->sample->note_to_use)
+		note = ip->sample->note_to_use;
+	else
+		note = e->a & 0x7f;
+	f = freq_table[note];
+
+	nv = 0;
+	for (i = 0, sp = ip->sample; i < ip->samples; i++, sp++) {
+		if (sp->low_freq <= f && sp->high_freq >= f) {
+			vlist[nv] = find_voice(e);
+			voice[vlist[nv]].orig_frequency = f;
+			voice[vlist[nv]].sample = sp;
+			nv++;
+		}
+	}
+
+	if (nv == 0) {
+		cdiff = 0x7FFFFFFF;
+		closest = sp = ip->sample;
+		for (i = 0; i < ip->samples; i++, sp++) {
+			diff = sp->root_freq - f;
+			if (diff < 0) diff = -diff;
+			if (diff < cdiff) {
+				cdiff = diff;
+				closest = sp;
+			}
+		}
+		vlist[nv] = find_voice(e);
+		voice[vlist[nv]].orig_frequency = f;
+		voice[vlist[nv]].sample = closest;
+		nv++;
 	}
 
-      if (ip->sample->note_to_use) /* Fixed-pitch instrument? */
-	voice[i].orig_frequency=freq_table[(int)(ip->sample->note_to_use)];
-      else
-	voice[i].orig_frequency=freq_table[e->a & 0x7F];
-      select_sample(i, ip);
-    }
+	return nv;
+}
+
+static void start_note(MidiEvent *e, int i)
+{
+  int j;
 
   voice[i].status=VOICE_ON;
   voice[i].channel=e->channel;
@@ -373,7 +349,7 @@
 }
 
 /* Only one instance of a note can be playing on a single channel. */
-static void note_on(MidiEvent *e)
+static int find_voice(MidiEvent *e)
 {
   int i=voices, lowest=-1; 
   int32 lv=0x7FFFFFFF, v;
@@ -390,8 +366,7 @@
   if (lowest != -1)
     {
       /* Found a free voice. */
-      start_note(e,lowest);
-      return;
+      return lowest;
     }
   
   /* Look for the decaying note with the lowest volume */
@@ -420,12 +395,27 @@
 	 we could use a reserve of voices to play dying notes only. */
       
       cut_notes++;
+      /*fprintf(stderr, "cuts\n");*/
       voice[lowest].status=VOICE_FREE;
       ctl->note(lowest);
-      start_note(e,lowest);
+      return lowest;
     }
-  else
+  else {
     lost_notes++;
+    /*fprintf(stderr, "losts\n");*/
+  }
+  return 0;
+}
+
+static void note_on(MidiEvent *e)
+{
+	int i, nv;
+	int vlist[32];
+
+	nv = find_samples(e, vlist);
+	for (i = 0; i < nv; i++) {
+		start_note(e, vlist[i]);
+	}
 }
 
 static void finish_note(int i)
@@ -463,7 +453,6 @@
 	  }
 	else
 	  finish_note(i);
-	return;
       }
 }
 
diff -ruN timidity-0.2i/readmidi.c timidity-0.2i+tr+sf/readmidi.c
--- timidity-0.2i/readmidi.c	Mon May 20 22:09:47 1996
+++ timidity-0.2i+tr+sf/readmidi.c	Thu Feb 20 13:23:58 1997
@@ -222,8 +222,8 @@
 
 		  case 100: nrpn=0; rpn_msb[lastchan]=b; break;
 		  case 101: nrpn=0; rpn_lsb[lastchan]=b; break;
-		  case 99: nrpn=1; rpn_msb[lastchan]=b; break;
-		  case 98: nrpn=1; rpn_lsb[lastchan]=b; break;
+		  case 98: nrpn=1; rpn_msb[lastchan]=b; break;
+		  case 99: nrpn=1; rpn_lsb[lastchan]=b; break;
 		    
 		  case 6:
 		    if (nrpn)
diff -ruN timidity-0.2i/readsbk.c timidity-0.2i+tr+sf/readsbk.c
--- timidity-0.2i/readsbk.c	Thu Jan  1 09:00:00 1970
+++ timidity-0.2i+tr+sf/readsbk.c	Mon Mar 24 20:33:03 1997
@@ -0,0 +1,436 @@
+/*================================================================
+ * readsbk.c:
+ *	read soundfont file
+ *================================================================*/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include "config.h"
+#include "sbk.h"
+
+/*----------------------------------------------------------------
+ * function prototypes
+ *----------------------------------------------------------------*/
+
+#define NEW(type,nums)	(type*)malloc(sizeof(type) * (nums))
+
+static int READCHUNK(tchunk *vp, FILE *fd)
+{
+	if (fread(vp, 8, 1, fd) != 1) return -1;
+	vp->size = LE_LONG(vp->size);
+	return 1;
+}
+
+static int READDW(uint32 *vp, FILE *fd)
+{
+	if (fread(vp, 4, 1, fd) != 1) return -1;
+	*vp = LE_LONG(*vp);
+	return 1;
+}	
+
+static int READW(uint16 *vp, FILE *fd)
+{
+	if (fread(vp, 2, 1, fd) != 1) return -1;
+	*vp = LE_SHORT(*vp);
+	return 1;
+}
+
+#define READSTR(var,fd)	fread(var, 20, 1, fd)
+#define READID(var,fd)	fread(var, 1, 4, fd)
+#define READB(var,fd)	fread(var, 1, 1, fd)
+#define SKIPB(fd)	{uint8 dummy; fread(&dummy, 1, 1, fd);}
+#define SKIPW(fd)	{uint16 dummy; fread(&dummy, 2, 1, fd);}
+#define SKIPDW(fd)	{uint32 dummy; fread(&dummy, 4, 1, fd);}
+
+static int getchunk(char *id);
+static void process_chunk(int id, int s, SFInfo *sf, FILE *fd);
+static void load_sample_names(int size, SFInfo *sf, FILE *fd);
+static void load_preset_header(int size, SFInfo *sf, FILE *fd);
+static void load_inst_header(int size, SFInfo *sf, FILE *fd);
+static void load_bag(int size, SFInfo *sf, FILE *fd, int *totalp, unsigned short **bufp);
+static void load_gen(int size, SFInfo *sf, FILE *fd, int *totalp, tgenrec **bufp);
+static void load_sample_info(int size, SFInfo *sf, FILE *fd);
+
+
+
+enum {
+	/* level 0 */
+	UNKN_ID, RIFF_ID, LIST_ID,
+	/* level 1 */
+	INFO_ID, SDTA_ID, PDTA_ID,
+	/* info stuff */
+	IFIL_ID, ISNG_ID, IROM_ID, INAM_ID, IVER_ID, IPRD_ID, ICOP_ID,
+	/* sample data stuff */
+	SNAM_ID, SMPL_ID,
+	/* preset stuff */
+	PHDR_ID, PBAG_ID, PMOD_ID, PGEN_ID,
+	/* inst stuff */
+	INST_ID, IBAG_ID, IMOD_ID, IGEN_ID,
+	/* sample header */
+	SHDR_ID,
+};
+
+
+/*----------------------------------------------------------------
+ * debug routine
+ *----------------------------------------------------------------*/
+
+#if 0
+static void debugid(char *tag, char *p)
+{
+	char buf[5]; strncpy(buf, p, 4); buf[4]=0;
+	fprintf(stderr,"[%s:%s]\n", tag, buf);
+}
+
+static void debugname(char *tag, char *p)
+{
+	char buf[21]; strncpy(buf, p, 20); buf[20]=0;
+	fprintf(stderr,"[%s:%s]\n", tag, buf);
+}
+
+static void debugval(char *tag, int v)
+{
+	fprintf(stderr, "[%s:%d]\n", tag, v);
+}
+#else
+#define debugid(t,s) /**/
+#define debugname(t,s) /**/
+#define debugval(t,v) /**/
+#endif
+
+
+/*----------------------------------------------------------------
+ * load sbk file
+ *----------------------------------------------------------------*/
+
+void load_sbk(FILE *fd, SFInfo *sf)
+{
+	tchunk chunk, subchunk;
+
+	READID(sf->sbkh.riff, fd);
+	READDW(&sf->sbkh.size, fd);
+	READID(sf->sbkh.sfbk, fd);
+
+	sf->in_rom = 1;
+	while (! feof(fd)) {
+		READID(chunk.id, fd);
+		switch (getchunk(chunk.id)) {
+		case LIST_ID:
+			READDW(&chunk.size, fd);
+			READID(subchunk.id, fd);
+			process_chunk(getchunk(subchunk.id), chunk.size - 4, sf, fd);
+			break;
+		}
+	}
+}
+
+
+/*----------------------------------------------------------------
+ * free buffer
+ *----------------------------------------------------------------*/
+
+void free_sbk(SFInfo *sf)
+{
+	free(sf->samplenames);
+	free(sf->presethdr);
+	free(sf->sampleinfo);
+	free(sf->insthdr);
+	free(sf->presetbag);
+	free(sf->instbag);
+	free(sf->presetgen);
+	free(sf->instgen);
+	/* if (sf->sf_name) free(sf->sf_name); */
+	memset(sf, 0, sizeof(*sf));
+}
+
+
+
+/*----------------------------------------------------------------
+ * get id value
+ *----------------------------------------------------------------*/
+
+static int getchunk(char *id)
+{
+	static struct idstring {
+		char *str;
+		int id;
+	} idlist[] = {
+		{"LIST", LIST_ID},
+		{"INFO", INFO_ID},
+		{"sdta", SDTA_ID},
+		{"snam", SNAM_ID},
+		{"smpl", SMPL_ID},
+		{"pdta", PDTA_ID},
+		{"phdr", PHDR_ID},
+		{"pbag", PBAG_ID},
+		{"pmod", PMOD_ID},
+		{"pgen", PGEN_ID},
+		{"inst", INST_ID},
+		{"ibag", IBAG_ID},
+		{"imod", IMOD_ID},
+		{"igen", IGEN_ID},
+		{"shdr", SHDR_ID},
+		{"ifil", IFIL_ID},
+		{"isng", ISNG_ID},
+		{"irom", IROM_ID},
+		{"iver", IVER_ID},
+		{"INAM", INAM_ID},
+		{"IPRD", IPRD_ID},
+		{"ICOP", ICOP_ID},
+	};
+
+	int i;
+
+	for (i = 0; i < sizeof(idlist)/sizeof(idlist[0]); i++) {
+		if (strncmp(id, idlist[i].str, 4) == 0) {
+			debugid("ok", id);
+			return idlist[i].id;
+		}
+	}
+
+	debugid("xx", id);
+	return UNKN_ID;
+}
+
+
+static void load_sample_names(int size, SFInfo *sf, FILE *fd)
+{
+	int i;
+	sf->nrsamples = size / 20;
+	sf->samplenames = NEW(tsamplenames, sf->nrsamples);
+	for (i = 0; i < sf->nrsamples; i++) {
+		READSTR(sf->samplenames[i].name, fd);
+	}
+}
+
+static void load_preset_header(int size, SFInfo *sf, FILE *fd)
+{
+	int i;
+	sf->nrpresets = size / 38;
+	sf->presethdr = NEW(tpresethdr, sf->nrpresets);
+	for (i = 0; i < sf->nrpresets; i++) {
+		READSTR(sf->presethdr[i].name, fd);
+		READW(&sf->presethdr[i].preset, fd);
+		READW(&sf->presethdr[i].bank, fd);
+		READW(&sf->presethdr[i].bagNdx, fd);
+		SKIPDW(fd); /* lib */
+		SKIPDW(fd); /* genre */
+		SKIPDW(fd); /* morph */
+	}
+}
+
+static void load_inst_header(int size, SFInfo *sf, FILE *fd)
+{
+	int i;
+
+	sf->nrinsts = size / 22;
+	sf->insthdr = NEW(tinsthdr, sf->nrinsts);
+	for (i = 0; i < sf->nrinsts; i++) {
+		READSTR(sf->insthdr[i].name, fd);
+		READW(&sf->insthdr[i].bagNdx, fd);
+	}
+		
+}
+
+static void load_bag(int size, SFInfo *sf, FILE *fd, int *totalp, unsigned short **bufp)
+{
+	unsigned short *buf;
+	int i;
+
+	debugval("bagsize", size);
+	size /= 4;
+	buf = NEW(short, size);
+	for (i = 0; i < size; i++) {
+		READW(&buf[i], fd);
+		SKIPW(fd); /* mod */
+	}
+	*totalp = size;
+	*bufp = buf;
+}
+
+static void load_gen(int size, SFInfo *sf, FILE *fd, int *totalp, tgenrec **bufp)
+{
+	tgenrec *buf;
+	int i;
+
+	debugval("gensize", size);
+	size /= 4;
+	buf = NEW(tgenrec, size);
+	for (i = 0; i < size; i++) {
+		READW(&buf[i].oper, fd);
+		READW(&buf[i].amount, fd);
+	}
+	*totalp = size;
+	*bufp = buf;
+}
+
+static void load_sample_info(int size, SFInfo *sf, FILE *fd)
+{
+	int i;
+
+	debugval("infosize", size);
+	if (sf->version > 1) {
+		sf->nrinfos = size / 46;
+		sf->nrsamples = sf->nrinfos;
+		sf->sampleinfo = NEW(tsampleinfo, sf->nrinfos);
+		sf->samplenames = NEW(tsamplenames, sf->nrsamples);
+	}
+	else  {
+		sf->nrinfos = size / 16;
+		sf->sampleinfo = NEW(tsampleinfo, sf->nrinfos);
+	}
+
+
+	for (i = 0; i < sf->nrinfos; i++) {
+		if (sf->version > 1)
+			READSTR(sf->samplenames[i].name, fd);
+		READDW(&sf->sampleinfo[i].startsample, fd);
+		READDW(&sf->sampleinfo[i].endsample, fd);
+		READDW(&sf->sampleinfo[i].startloop, fd);
+		READDW(&sf->sampleinfo[i].endloop, fd);
+		if (sf->version > 1) {
+			READDW(&sf->sampleinfo[i].samplerate, fd);
+			READB(&sf->sampleinfo[i].originalPitch, fd);
+			READB(&sf->sampleinfo[i].pitchCorrection, fd);
+			READW(&sf->sampleinfo[i].samplelink, fd);
+			READW(&sf->sampleinfo[i].sampletype, fd);
+		} else {
+			if (sf->sampleinfo[i].startsample == 0)
+				sf->in_rom = 0;
+			sf->sampleinfo[i].startloop++;
+			sf->sampleinfo[i].endloop += 2;
+			sf->sampleinfo[i].samplerate = 44100;
+			sf->sampleinfo[i].originalPitch = 60;
+			sf->sampleinfo[i].pitchCorrection = 0;
+			sf->sampleinfo[i].samplelink = 0;
+			if (sf->in_rom)
+				sf->sampleinfo[i].sampletype = 0x8001;
+			else
+				sf->sampleinfo[i].sampletype = 1;
+		}
+	}
+}
+
+
+/*
+ */
+
+static void process_chunk(int id, int s, SFInfo *sf, FILE *fd)
+{
+	int cid;
+	tchunk subchunk;
+
+	switch (id) {
+	case INFO_ID:
+		READCHUNK(&subchunk, fd);
+		while ((cid = getchunk(subchunk.id)) != LIST_ID) {
+			switch (cid) {
+			case IFIL_ID:
+				READW(&sf->version, fd);
+				READW(&sf->minorversion, fd);
+				break;
+			/*
+			case INAM_ID:
+				sf->sf_name = (char*)malloc(subchunk.size);
+				if (sf->sf_name == NULL) {
+					fprintf(stderr, "can't malloc\n");
+					exit(1);
+				}
+				fread(sf->sf_name, 1, subchunk.size, fd);
+				break;
+			*/
+			default:
+				fseek(fd, subchunk.size, SEEK_CUR);
+				break;
+			}
+			READCHUNK(&subchunk, fd);
+			if (feof(fd))
+				return;
+		}
+		fseek(fd, -8, SEEK_CUR); /* seek back */
+		break;
+
+	case SDTA_ID:
+		READCHUNK(&subchunk, fd);
+		while ((cid = getchunk(subchunk.id)) != LIST_ID) {
+			switch (cid) {
+			case SNAM_ID:
+				if (sf->version > 1) {
+					printf("**** version 2 has obsolete format??\n");
+					fseek(fd, subchunk.size, SEEK_CUR);
+				} else
+					load_sample_names(subchunk.size, sf, fd);
+				break;
+			case SMPL_ID:
+				sf->samplepos = ftell(fd);
+				sf->samplesize = subchunk.size;
+				fseek(fd, subchunk.size, SEEK_CUR);
+			}
+			READCHUNK(&subchunk, fd);
+			if (feof(fd))
+				return;
+		}
+		fseek(fd, -8, SEEK_CUR); /* seek back */
+		break;
+
+	case PDTA_ID:
+		READCHUNK(&subchunk, fd);
+		while ((cid = getchunk(subchunk.id)) != LIST_ID) {
+			switch (cid) {
+			case PHDR_ID:
+				load_preset_header(subchunk.size, sf, fd);
+				break;
+
+			case PBAG_ID:
+				load_bag(subchunk.size, sf, fd,
+					 &sf->nrpbags, &sf->presetbag);
+				break;
+
+			case PMOD_ID: /* ignored */
+				fseek(fd, subchunk.size, SEEK_CUR);
+				break;
+
+			case PGEN_ID:
+				load_gen(subchunk.size, sf, fd,
+					 &sf->nrpgens, &sf->presetgen);
+				break;
+
+			case INST_ID:
+				load_inst_header(subchunk.size, sf, fd);
+				break;
+
+			case IBAG_ID:
+				load_bag(subchunk.size, sf, fd,
+					 &sf->nribags, &sf->instbag);
+				break;
+
+			case IMOD_ID: /* ingored */
+				fseek(fd, subchunk.size, SEEK_CUR);
+				break;
+
+			case IGEN_ID:
+				load_gen(subchunk.size, sf, fd,
+					 &sf->nrigens, &sf->instgen);
+				break;
+				
+			case SHDR_ID:
+				load_sample_info(subchunk.size, sf, fd);
+				break;
+
+			default:
+				fprintf(stderr, "unknown id\n");
+				fseek(fd, subchunk.size, SEEK_CUR);
+				break;
+			}
+			READCHUNK(&subchunk, fd);
+			if (feof(fd)) {
+				debugid("file", "EOF");
+				return;
+			}
+		}
+		fseek(fd, -8, SEEK_CUR); /* rewind */
+		break;
+	}
+}
+
diff -ruN timidity-0.2i/sbk.h timidity-0.2i+tr+sf/sbk.h
--- timidity-0.2i/sbk.h	Thu Jan  1 09:00:00 1970
+++ timidity-0.2i+tr+sf/sbk.h	Mon Mar 24 18:16:28 1997
@@ -0,0 +1,94 @@
+/*================================================================
+ * SoundFont(tm) file format
+ *================================================================*/
+
+#ifndef SBK_H_DEF
+#define SBK_H_DEF
+
+typedef struct _tchunk {
+	char id[4];
+	int32 size;
+} tchunk;
+
+typedef struct _tsbkheader {
+	char riff[4];	/* RIFF */
+	int32 size;	/* size of sbk after there bytes */
+	char sfbk[4];	/* sfbk id */
+} tsbkheader;
+
+typedef struct _tsamplenames {
+	char name[20];
+} tsamplenames;
+
+typedef struct _tpresethdr {
+	char name[20];
+	uint16 preset, bank, bagNdx;
+	/*int lib, genre, morphology;*/ /* reserved */
+} tpresethdr;
+
+typedef struct _tsampleinfo {
+	int32 startsample, endsample;
+	int32 startloop, endloop;
+	/* ver.2 additional info */
+	int32 samplerate;
+	uint8 originalPitch;
+	uint8 pitchCorrection;
+	uint16 samplelink;
+	uint16 sampletype;  /*1=mono, 2=right, 4=left, 8=linked, $8000=ROM*/
+} tsampleinfo;
+
+typedef struct _tinsthdr {
+	char name[20];
+	uint16 bagNdx;
+} tinsthdr;
+
+typedef struct _tgenrec {
+	int16 oper;
+	int16 amount;
+} tgenrec;
+
+
+/*
+ *
+ */
+
+typedef struct _SFInfo {
+	uint16 version, minorversion;
+	int32 samplepos, samplesize;
+
+	int nrsamples;
+	tsamplenames *samplenames;
+
+	int nrpresets;
+	tpresethdr *presethdr;
+	
+	int nrinfos;
+	tsampleinfo *sampleinfo;
+
+	int nrinsts;
+	tinsthdr *insthdr;
+
+	int nrpbags, nribags;
+	uint16 *presetbag, *instbag;
+
+	int nrpgens, nrigens;
+	tgenrec *presetgen, *instgen;
+
+	tsbkheader sbkh;
+
+	/*char *sf_name;*/
+
+	int in_rom;
+
+} SFInfo;
+
+
+/*----------------------------------------------------------------
+ * functions
+ *----------------------------------------------------------------*/
+
+void load_sbk(FILE *fp, SFInfo *sf);
+void free_sbk(SFInfo *sf);
+void sbk_to_text(char *text, int type, int val, SFInfo *sf);
+
+#endif
diff -ruN timidity-0.2i/sbktext.c timidity-0.2i+tr+sf/sbktext.c
--- timidity-0.2i/sbktext.c	Thu Jan  1 09:00:00 1970
+++ timidity-0.2i+tr+sf/sbktext.c	Mon Mar 24 21:31:24 1997
@@ -0,0 +1,132 @@
+/*================================================================
+ * print the sbk/sf2 information
+ *
+ * Copyright (C) 1996,1997 Takashi Iwai
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *================================================================*/
+
+#include <stdio.h>
+#include <string.h>
+#include "config.h"
+#include "sbk.h"
+#include "sflayer.h"
+
+static SFInfo sfinfo;
+
+static char *getname(char *p);
+static void print_sbk(SFInfo *sf, FILE *fout);
+
+
+void main(int argc, char **argv)
+{
+	FILE *fp;
+
+	if (argc < 2) {
+		fprintf(stderr, "usage: sf2text SoundFontFile [textfile]\n");
+		exit(1);
+	}
+
+	if ((fp = fopen(argv[1], "r")) == NULL) {
+		fprintf(stderr, "can't open SoundFont file %s\n", argv[1]);
+		exit(1);
+	}
+
+	load_sbk(fp, &sfinfo);
+	fclose(fp);
+
+	fp = stdout;
+	if (argc >= 3 && (fp = fopen(argv[2], "w")) == NULL) {
+		fprintf(stderr, "can't open text file %s\n", argv[2]);
+		exit(1);
+	}
+	print_sbk(&sfinfo, fp);
+
+	exit(0);
+}
+
+
+static char *getname(p)
+	char *p;
+{
+	static char buf[21];
+	strncpy(buf, p, 20);
+	buf[20] = 0;
+	return buf;
+}
+
+
+static void print_sbk(SFInfo *sf, FILE *fout)
+{
+	char buf[1000];
+	int i, ninfos;
+	tpresethdr *ip;
+	tinsthdr *tp;
+	tsampleinfo *hp;
+
+	fprintf(fout, "** SoundFont: %d %d\n", sf->version, sf->minorversion);
+	fprintf(fout, "** SampleData: %d %d\n", (int)sf->samplepos, (int)sf->samplesize);
+
+	fprintf(fout, "\n** Presets: %d\n", sf->nrpresets-1);
+	for (i = 0, ip = sf->presethdr; i < sf->nrpresets-1; ip++, i++) {
+		int b;
+		fprintf(fout, "[%s] preset=%d bank=%d layer=%d\n",
+		       getname(ip->name), ip->preset, ip->bank,
+		       ip[1].bagNdx - ip->bagNdx);
+		for (b = ip->bagNdx; b < ip[1].bagNdx; b++) {
+			int g;
+			fprintf(fout, "    BAG %d\n", sf->presetbag[b+1] - sf->presetbag[b]);
+			for (g = sf->presetbag[b]; g < sf->presetbag[b+1]; g++) {
+				sbk_to_text(buf, sf->presetgen[g].oper,
+					    sf->presetgen[g].amount, sf);
+				fprintf(fout, "    %s\n", buf);
+			}
+		}
+	}
+
+	fprintf(fout, "\n** Instruments: %d\n", sf->nrinsts-1);
+	for (i = 0, tp = sf->insthdr; i < sf->nrinsts-1; tp++, i++) {
+		int b;
+		fprintf(fout, "[%s] layer=%d\n", getname(tp->name), tp[1].bagNdx - tp->bagNdx);
+		for (b = tp->bagNdx; b < tp[1].bagNdx; b++) {
+			int g;
+			fprintf(fout, "    BAG %d\n", sf->instbag[b+1] - sf->instbag[b]);
+			for (g = sf->instbag[b]; g < sf->instbag[b+1]; g++) {
+				sbk_to_text(buf, sf->instgen[g].oper,
+					    sf->instgen[g].amount, sf);
+				fprintf(fout, "    %s\n", buf);
+			}
+		}
+	}
+
+	if (sf->version == 1)
+		ninfos = sf->nrinfos;
+	else
+		ninfos = sf->nrinfos - 1;
+	fprintf(fout, "\n** SampleInfo: %d\n", ninfos);
+	for (i = 0, hp = sf->sampleinfo; i < ninfos; hp++, i++) {
+		fprintf(fout, "[%s] start=%x end=%x startloop=%x endloop=%x\n",
+		       sf->samplenames[i].name, hp->startsample, hp->endsample,
+		       hp->startloop, hp->endloop);
+		if (sf->version > 1) {
+			fprintf(fout, "    rate=%d, pitch=%d:%d, link=%d, type=%x\n",
+			       hp->samplerate,
+			       hp->originalPitch,
+			       hp->pitchCorrection,
+			       hp->samplelink,
+			       hp->sampletype);
+		}
+	}
+}
diff -ruN timidity-0.2i/sflayer.h timidity-0.2i+tr+sf/sflayer.h
--- timidity-0.2i/sflayer.h	Thu Jan  1 09:00:00 1970
+++ timidity-0.2i+tr+sf/sflayer.h	Mon Mar 24 17:30:01 1997
@@ -0,0 +1,74 @@
+/*================================================================
+ * sflayer.h
+ *	SoundFont layer structure
+ *================================================================*/
+
+#ifndef SFLAYER_H_DEF
+#define SFLAYER_H_DEF
+
+enum {
+	SF_startAddrs,         /* sample start address -4 (0 to * 0xffffff) */
+        SF_endAddrs,
+        SF_startloopAddrs,     /* loop start address -4 (0 to * 0xffffff) */
+        SF_endloopAddrs,       /* loop end address -3 (0 to * 0xffffff) */
+        SF_startAddrsHi,       /* high word of startAddrs */
+        SF_lfo1ToPitch,        /* main fm: lfo1-> pitch */
+        SF_lfo2ToPitch,        /* aux fm:  lfo2-> pitch */
+        SF_env1ToPitch,        /* pitch env: env1(aux)-> pitch */
+        SF_initialFilterFc,    /* initial filter cutoff */
+        SF_initialFilterQ,     /* filter Q */
+        SF_lfo1ToFilterFc,     /* filter modulation: lfo1 -> filter * cutoff */
+        SF_env1ToFilterFc,     /* filter env: env1(aux)-> filter * cutoff */
+        SF_endAddrsHi,         /* high word of endAddrs */
+        SF_lfo1ToVolume,       /* tremolo: lfo1-> volume */
+        SF_env2ToVolume,       /* Env2Depth: env2-> volume */
+        SF_chorusEffectsSend,  /* chorus */
+        SF_reverbEffectsSend,  /* reverb */
+        SF_panEffectsSend,     /* pan */
+        SF_auxEffectsSend,     /* pan auxdata (internal) */
+        SF_sampleVolume,       /* used internally */
+        SF_unused3,
+        SF_delayLfo1,          /* delay 0x8000-n*(725us) */
+        SF_freqLfo1,           /* frequency */
+        SF_delayLfo2,          /* delay 0x8000-n*(725us) */
+        SF_freqLfo2,           /* frequency */
+        SF_delayEnv1,          /* delay 0x8000 - n(725us) */
+        SF_attackEnv1,         /* attack */
+        SF_holdEnv1,             /* hold */
+        SF_decayEnv1,            /* decay */
+        SF_sustainEnv1,          /* sustain */
+        SF_releaseEnv1,          /* release */
+        SF_autoHoldEnv1,
+        SF_autoDecayEnv1,
+        SF_delayEnv2,            /* delay 0x8000 - n(725us) */
+        SF_attackEnv2,           /* attack */
+        SF_holdEnv2,             /* hold */
+        SF_decayEnv2,            /* decay */
+        SF_sustainEnv2,          /* sustain */
+        SF_releaseEnv2,          /* release */
+        SF_autoHoldEnv2,
+        SF_autoDecayEnv2,
+        SF_instrument,           /* */
+        SF_nop,
+        SF_keyRange,             /* */
+        SF_velRange,             /* */
+        SF_startloopAddrsHi,     /* high word of startloopAddrs */
+        SF_keynum,               /* */
+        SF_velocity,             /* */
+        SF_instVol,              /* */
+        SF_keyTuning,
+        SF_endloopAddrsHi,       /* high word of endloopAddrs */
+        SF_coarseTune,
+        SF_fineTune,
+        SF_sampleId,
+        SF_sampleFlags,
+        SF_samplePitch,          /* SF1 only */
+        SF_scaleTuning,
+        SF_keyExclusiveClass,
+        SF_rootKey,
+	SF_EOF,
+};
+
+#define PARM_SIZE	SF_EOF
+
+#endif
diff -ruN timidity-0.2i/sndfont.c timidity-0.2i+tr+sf/sndfont.c
--- timidity-0.2i/sndfont.c	Thu Jan  1 09:00:00 1970
+++ timidity-0.2i+tr+sf/sndfont.c	Thu Apr  3 23:24:56 1997
@@ -0,0 +1,1025 @@
+/*================================================================
+ * SoundFont file extension
+ *	written by Takashi Iwai <iwai@dragon.mm.t.u-tokyo.ac.jp>
+ *================================================================*/
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <math.h>
+#include "config.h"
+#include "common.h"
+#include "tables.h"
+#include "instrum.h"
+#include "playmidi.h"
+#include "controls.h"
+#include "sbk.h"
+#include "sflayer.h"
+#include "output.h"
+#include "filter.h"
+#include "resample.h"
+
+/*----------------------------------------------------------------
+ * compile flags
+ *----------------------------------------------------------------*/
+
+/*#define SF_CLOSE_EACH_FILE*/
+
+/*#define SF_SUPPRESS_ENVELOPE*/
+/*#define SF_SUPPRESS_TREMOLO*/
+/*#define SF_SUPPRESS_VIBRATO*/
+#define SF_SUPPRESS_CUTOFF
+
+/*----------------------------------------------------------------
+ * local parameters
+ *----------------------------------------------------------------*/
+
+typedef struct _Layer {
+	int16 val[PARM_SIZE];
+	int8 set[PARM_SIZE];
+} Layer;
+
+typedef struct _SampleList {
+	Sample v;
+	struct _SampleList *next;
+	int32 startsample, endsample;
+	int32 cutoff_freq;
+	float resonance;
+} SampleList;
+
+typedef struct _InstList {
+	int bank, preset, keynote;
+	int samples;
+	int order;
+	SampleList *slist;
+	struct _InstList *next;
+} InstList;
+
+typedef struct SFInsts {
+	char *fname;
+	FILE *fd;
+	uint16 version, minorversion;
+	int32 samplepos, samplesize;
+	InstList *instlist;
+} SFInsts;
+
+typedef struct _SFExclude {
+	int bank, preset, keynote;
+	struct _SFExclude *next;
+} SFExclude;
+
+typedef struct _SFOrder {
+	int bank, preset, keynote;
+	int order;
+	struct _SFOrder *next;
+} SFOrder;
+
+
+/*----------------------------------------------------------------*/
+
+static void free_sample(InstList *ip);
+static Instrument *load_from_file(SFInsts *rec, InstList *ip);
+static int is_excluded(int bank, int preset, int keynote);
+static void free_exclude(void);
+static int is_ordered(int bank, int preset, int keynote);
+static void free_order(void);
+static void parse_preset(SFInsts *rec, SFInfo *sf, int preset, int order);
+static void parse_gen(Layer *lay, tgenrec *gen);
+static void parse_preset_layer(Layer *lay, SFInfo *sf, int idx);
+static void merge_layer(Layer *dst, Layer *src);
+static int search_inst(Layer *lay);
+static void parse_inst(SFInsts *rec, Layer *pr_lay, SFInfo *sf, int preset, int inst, int order);
+static void parse_inst_layer(Layer *lay, SFInfo *sf, int idx);
+static int search_sample(Layer *lay);
+static void append_layer(Layer *dst, Layer *src, SFInfo *sf);
+static void make_inst(SFInsts *rec, Layer *lay, SFInfo *sf, int pr_idx, int in_idx, int order);
+static int32 calc_root_pitch(Layer *lay, SFInfo *sf, SampleList *sp);
+static void convert_volume_envelope(Layer *lay, SFInfo *sf, SampleList *sp);
+static int32 to_offset(int offset);
+static int32 calc_rate(int diff, int time);
+static int32 to_msec(Layer *lay, SFInfo *sf, int index);
+static float calc_volume(Layer *lay, SFInfo *sf);
+static int32 calc_sustain(Layer *lay, SFInfo *sf);
+static void convert_tremolo(Layer *lay, SFInfo *sf, SampleList *sp);
+static void convert_vibrato(Layer *lay, SFInfo *sf, SampleList *sp);
+static void do_lowpass(Sample *sp, int32 freq, float resonance);
+static void calc_cutoff(Layer *lay, SFInfo *sf, SampleList *sp);
+static void calc_filterQ(Layer *lay, SFInfo *sf, SampleList *sp);
+
+/*----------------------------------------------------------------*/
+
+
+static SFInsts sfrec;
+static SFExclude *sfexclude;
+static SFOrder *sforder;
+
+int cutoff_allowed = 0;
+
+
+void init_soundfont(char *fname, int order)
+{
+	static SFInfo sfinfo;
+	int i;
+
+	ctl->cmsg(CMSG_INFO, VERB_NOISY, "init soundfonts `%s'", fname);
+
+	if ((sfrec.fd = open_file(fname, 1, OF_VERBOSE)) == NULL) {
+		ctl->cmsg(CMSG_ERROR, VERB_NORMAL,
+			  "can't open soundfont file %s", fname);
+		return;
+	}
+	sfrec.fname = strcpy((char*)safe_malloc(strlen(fname)+1), fname);
+	load_sbk(sfrec.fd, &sfinfo);
+
+	for (i = 0; i < sfinfo.nrpresets; i++) {
+		int bank = sfinfo.presethdr[i].bank;
+		int preset = sfinfo.presethdr[i].preset;
+		if (is_excluded(bank, preset, -1))
+			continue;
+		if (bank == 128) {
+			if (!drumset[preset]) {
+				drumset[preset] = safe_malloc(sizeof(ToneBank));
+				memset(drumset[preset], 0, sizeof(ToneBank));
+			}
+		} else {
+			if (!tonebank[bank]) {
+				tonebank[bank] = safe_malloc(sizeof(ToneBank));
+				memset(tonebank[bank], 0, sizeof(ToneBank));
+			}
+		}
+		parse_preset(&sfrec, &sfinfo, i, order);
+	}
+
+	/* copy header info */
+	sfrec.version = sfinfo.version;
+	sfrec.minorversion = sfinfo.minorversion;
+	sfrec.samplepos = sfinfo.samplepos;
+	sfrec.samplesize = sfinfo.samplesize;
+
+	free_sbk(&sfinfo);
+
+#ifdef SF_CLOSE_EACH_FILE
+	fclose(sfrec.fd);
+	sfrec.fd = NULL;
+#endif
+}
+
+
+static void free_sample(InstList *ip)
+{
+	SampleList *sp, *snext;
+	for (sp = ip->slist; sp; sp = snext) {
+		snext = sp->next;
+		free(sp);
+	}
+	free(ip);
+}
+
+void end_soundfont(void)
+{
+	InstList *ip, *next;
+
+	if (sfrec.fd) {
+		fclose(sfrec.fd);
+		sfrec.fd = NULL;
+	}
+	free(sfrec.fname); sfrec.fname = NULL;
+
+	for (ip = sfrec.instlist; ip; ip = next) {
+		next = ip->next;
+		free_sample(ip);
+	}
+	sfrec.instlist = NULL;
+
+	free_exclude();
+	free_order();
+}
+
+
+/*----------------------------------------------------------------
+ * get converted instrument info and load the wave data from file
+ *----------------------------------------------------------------*/
+
+Instrument *load_soundfont(int order, int bank, int preset, int keynote)
+{
+	InstList *ip;
+	Instrument *inst = NULL;
+
+	if (sfrec.fd == NULL) {
+		if (sfrec.fname == NULL)
+			return NULL;
+		if ((sfrec.fd = open_file(sfrec.fname, 1, OF_VERBOSE)) == NULL) {
+			ctl->cmsg(CMSG_ERROR, VERB_NORMAL,
+				  "can't open soundfont file %s", sfrec.fname);
+			return NULL;
+		}
+	}
+
+	for (ip = sfrec.instlist; ip; ip = ip->next) {
+		if (ip->bank == bank && ip->preset == preset &&
+		    (keynote < 0 || keynote == ip->keynote) &&
+		    ip->order == order)
+			break;
+	}
+	if (ip && ip->samples)
+		inst = load_from_file(&sfrec, ip);
+
+#ifdef SF_CLOSE_EACH_FILE
+	fclose(sfrec.fd);
+	sfrec.fd = NULL;
+#endif
+
+	return inst;
+}
+
+
+static Instrument *load_from_file(SFInsts *rec, InstList *ip)
+{
+	SampleList *sp;
+	Instrument *inst;
+	int i;
+
+	ctl->cmsg(CMSG_INFO, VERB_NOISY, "Loading SF bank%d prg%d note%d",
+		  ip->bank, ip->preset, ip->keynote);
+
+	inst = safe_malloc(sizeof(Instrument));
+	inst->type = INST_SF2;
+	inst->samples = ip->samples;
+	inst->sample = safe_malloc(sizeof(Sample)*ip->samples);
+	for (i = 0, sp = ip->slist; i < ip->samples && sp; i++, sp = sp->next) {
+		Sample *sample = inst->sample + i;
+#ifndef LITTLE_ENDIAN
+		int32 j;
+		int16 *tmp, s;
+#endif
+		memcpy(sample, &sp->v, sizeof(Sample));
+		sample->data = safe_malloc(sp->endsample);
+		fseek(rec->fd, sp->startsample, SEEK_SET);
+		fread(sample->data, sp->endsample, 1, rec->fd);
+#ifndef LITTLE_ENDIAN
+		tmp = (int16*)sample->data;
+		for (j = 0; j < sp->endsample/2; j++) {
+			s = LE_SHORT(*tmp);
+			*tmp++ = s;
+		}
+#endif
+
+		/* do some filtering if necessary */
+#ifndef SF_SUPPRESS_CUTOFF
+		if (sp->cutoff_freq > 0 && cutoff_allowed) {
+			/* restore the normal value */
+			sample->data_length >>= FRACTION_BITS;
+			fprintf(stderr, "bank=%d, preset=%d, keynote=%d / cutoff = %d / resonance = %g\n",
+				ip->bank, ip->preset, ip->keynote, sp->cutoff_freq, sp->resonance);
+			do_lowpass(sample, sp->cutoff_freq, sp->resonance);
+			/* convert again to the fractional value */
+			sample->data_length <<= FRACTION_BITS;
+		}
+#endif
+
+		if (antialiasing_allowed) {
+			/* restore the normal value */
+			sample->data_length >>= FRACTION_BITS;
+			antialiasing(sample, play_mode->rate);
+			/* convert again to the fractional value */
+			sample->data_length <<= FRACTION_BITS;
+		}
+
+		/* resample it if possible */
+		if (sample->note_to_use && !(sample->modes & MODES_LOOPING))
+			pre_resample(sample);
+
+#ifdef LOOKUP_HACK
+		/* squash the 16-bit data into 8 bits. */
+		{
+			uint8 *gulp,*ulp;
+			int16 *swp;
+			int l = sample->data_length >> FRACTION_BITS;
+			gulp = ulp = safe_malloc(l + 1);
+			swp = (int16 *)sample->data;
+			while (l--)
+				*ulp++ = (*swp++ >> 8) & 0xFF;
+			free(sample->data);
+			sample->data=(sample_t *)gulp;
+		}
+#endif
+	}
+	return inst;
+}
+
+
+/*----------------------------------------------------------------
+ * excluded samples
+ *----------------------------------------------------------------*/
+
+void exclude_soundfont(int bank, int preset, int keynote)
+{
+	SFExclude *rec;
+	rec = (SFExclude*)safe_malloc(sizeof(SFExclude));
+	rec->bank = bank;
+	rec->preset = preset;
+	rec->keynote = keynote;
+	rec->next = sfexclude;
+	sfexclude = rec;
+}
+
+/* check the instrument is specified to be excluded */
+static int is_excluded(int bank, int preset, int keynote)
+{
+	SFExclude *p;
+	for (p = sfexclude; p; p = p->next) {
+		if (p->bank == bank &&
+		    (p->preset < 0 || p->preset == preset) &&
+		    (p->keynote < 0 || p->keynote == keynote))
+			return 1;
+	}
+	return 0;
+}
+
+/* free exclude list */
+static void free_exclude(void)
+{
+	SFExclude *p, *next;
+	for (p = sfexclude; p; p = next) {
+		next = p->next;
+		free(p);
+	}
+	sfexclude = NULL;
+}
+
+
+/*----------------------------------------------------------------
+ * ordered samples
+ *----------------------------------------------------------------*/
+
+void order_soundfont(int bank, int preset, int keynote, int order)
+{
+	SFOrder *rec;
+	rec = (SFOrder*)safe_malloc(sizeof(SFOrder));
+	rec->bank = bank;
+	rec->preset = preset;
+	rec->keynote = keynote;
+	rec->order = order;
+	rec->next = sforder;
+	sforder = rec;
+}
+
+/* check the instrument is specified to be ordered */
+static int is_ordered(int bank, int preset, int keynote)
+{
+	SFOrder *p;
+	for (p = sforder; p; p = p->next) {
+		if (p->bank == bank &&
+		    (p->preset < 0 || p->preset == preset) &&
+		    (p->keynote < 0 || p->keynote == keynote))
+			return p->order;
+	}
+	return -1;
+}
+
+/* free order list */
+static void free_order(void)
+{
+	SFOrder *p, *next;
+	for (p = sforder; p; p = next) {
+		next = p->next;
+		free(p);
+	}
+	sforder = NULL;
+}
+
+
+/*----------------------------------------------------------------
+ * parse a preset
+ *----------------------------------------------------------------*/
+
+static void parse_preset(SFInsts *rec, SFInfo *sf, int preset, int order)
+{
+	int from_ndx, to_ndx;
+	Layer lay, glay;
+	int i, inst;
+
+	from_ndx = sf->presethdr[preset].bagNdx;
+	to_ndx = sf->presethdr[preset+1].bagNdx;
+
+	memset(&glay, 0, sizeof(glay));
+	for (i = from_ndx; i < to_ndx; i++) {
+		memset(&lay, 0, sizeof(Layer));
+		parse_preset_layer(&lay, sf, i);
+		inst = search_inst(&lay);
+		if (inst < 0) /* global layer */
+			memcpy(&glay, &lay, sizeof(Layer));
+		else {
+			append_layer(&lay, &glay, sf);
+			parse_inst(rec, &lay, sf, preset, inst, order);
+		}
+	}
+}
+
+/* map a generator operation to the layer structure */
+static void parse_gen(Layer *lay, tgenrec *gen)
+{
+	lay->set[gen->oper] = 1;
+	lay->val[gen->oper] = gen->amount;
+}
+
+/* parse preset generator layers */
+static void parse_preset_layer(Layer *lay, SFInfo *sf, int idx)
+{
+	int i;
+	for (i = sf->presetbag[idx]; i < sf->presetbag[idx+1]; i++)
+		parse_gen(lay, sf->presetgen + i);
+}
+
+/* merge two layers; never overrides on the destination */
+static void merge_layer(Layer *dst, Layer *src)
+{
+	int i;
+	for (i = 0; i < PARM_SIZE; i++) {
+		if (src->set[i] && !dst->set[i]) {
+			dst->val[i] = src->val[i];
+			dst->set[i] = 1;
+		}
+	}
+}
+
+/* search instrument id from the layer */
+static int search_inst(Layer *lay)
+{
+	if (lay->set[SF_instrument])
+		return lay->val[SF_instrument];
+	else
+		return -1;
+}
+
+/* parse an instrument */
+static void parse_inst(SFInsts *rec, Layer *pr_lay, SFInfo *sf, int preset, int inst, int order)
+{
+	int from_ndx, to_ndx;
+	int i, sample;
+	Layer lay, glay;
+
+	from_ndx = sf->insthdr[inst].bagNdx;
+	to_ndx = sf->insthdr[inst+1].bagNdx;
+
+	memcpy(&glay, pr_lay, sizeof(Layer));
+	for (i = from_ndx; i < to_ndx; i++) {
+		memset(&lay, 0, sizeof(Layer));
+		parse_inst_layer(&lay, sf, i);
+		sample = search_sample(&lay);
+		if (sample < 0) /* global layer */
+			append_layer(&glay, &lay, sf);
+		else {
+			append_layer(&lay, &glay, sf);
+			make_inst(rec, &lay, sf, preset, inst, order);
+		}
+	}
+}
+
+/* parse instrument generator layers */
+static void parse_inst_layer(Layer *lay, SFInfo *sf, int idx)
+{
+	int i;
+	for (i = sf->instbag[idx]; i < sf->instbag[idx+1]; i++)
+		parse_gen(lay, sf->instgen + i);
+}
+
+/* search a sample id from instrument layers */
+static int search_sample(Layer *lay)
+{
+	if (lay->set[SF_sampleId])
+		return lay->val[SF_sampleId];
+	else
+		return -1;
+}
+
+
+/* two (high/low) 8 bit values in 16 bit parameter */
+#define LO_VAL(val)	((val) & 0xff)
+#define HI_VAL(val)	(((val) >> 8) & 0xff)
+#define SET_LO(vp,val)	((vp) = ((vp) & 0xff00) | (val))
+#define SET_HI(vp,val)	((vp) = ((vp) & 0xff) | ((val) << 8))
+
+/* append two layers; parameters are added to the original value */
+static void append_layer(Layer *dst, Layer *src, SFInfo *sf)
+{
+	int i;
+	for (i = 0; i < PARM_SIZE; i++) {
+		if (src->set[i]) {
+			if (sf->version == 1 && i == SF_instVol)
+				dst->val[i] = (src->val[i] * 127) / 127;
+			else if (i == SF_keyRange || i == SF_velRange) {
+				/* high limit */
+				if (HI_VAL(dst->val[i]) > HI_VAL(src->val[i]))
+					SET_HI(dst->val[i], HI_VAL(src->val[i]));
+				/* low limit */
+				if (LO_VAL(dst->val[i]) < LO_VAL(src->val[i]))
+					SET_LO(dst->val[i], LO_VAL(src->val[i]));
+			} else
+				dst->val[i] += src->val[i];
+			dst->set[i] = 1;
+		}
+	}
+}
+
+/* convert layer info to timidity instrument strucutre */
+static void make_inst(SFInsts *rec, Layer *lay, SFInfo *sf, int pr_idx, int in_idx, int order)
+{
+	int bank = sf->presethdr[pr_idx].bank;
+	int preset = sf->presethdr[pr_idx].preset;
+	int keynote, n_order;
+	char **namep;
+	InstList *ip;
+	tsampleinfo *sample;
+	SampleList *sp;
+
+	sample = &sf->sampleinfo[lay->val[SF_sampleId]];
+	if (sample->sampletype & 0x8000) /* is ROM sample? */
+		return;
+
+	/* set bank/preset name */
+	if (bank == 128) {
+		keynote = LO_VAL(lay->val[SF_keyRange]);
+		namep = &drumset[preset]->tone[keynote].name;
+	} else {
+		keynote = -1;
+		namep = &tonebank[bank]->tone[preset].name;
+	}
+	if (is_excluded(bank, preset, keynote))
+		return;
+	if ((n_order = is_ordered(bank, preset, keynote)) >= 0)
+		order = n_order;
+
+	if (*namep == NULL) {
+		*namep = safe_malloc(21);
+		memcpy(*namep, sf->insthdr[in_idx].name, 20);
+		(*namep)[20] = 0;
+	}
+
+	/* search current instrument list */
+	for (ip = rec->instlist; ip; ip = ip->next) {
+		if (ip->bank == bank && ip->preset == preset &&
+		    (keynote < 0 || keynote == ip->keynote))
+			break;
+	}
+	if (ip == NULL) {
+		ip = (InstList*)safe_malloc(sizeof(InstList));
+		ip->bank = bank;
+		ip->preset = preset;
+		ip->keynote = keynote;
+		ip->order = order;
+		ip->samples = 0;
+		ip->slist = NULL;
+		ip->next = rec->instlist;
+		rec->instlist = ip;
+	}
+
+	/* add a sample */
+	sp = (SampleList*)safe_malloc(sizeof(SampleList));
+	sp->next = ip->slist;
+	ip->slist = sp;
+	ip->samples++;
+
+	/* set sample position */
+	sp->startsample = (lay->val[SF_startAddrsHi] << 16)
+		+ lay->val[SF_startAddrs]
+		+ sample->startsample;
+	sp->endsample = (lay->val[SF_endAddrsHi] << 16)
+		+ lay->val[SF_endAddrs]
+		+ sample->endsample - sp->startsample;
+
+	/* set loop position */
+	sp->v.loop_start = (lay->val[SF_startloopAddrsHi] << 16)
+		+ lay->val[SF_startloopAddrsHi]
+		+ sample->startloop - sp->startsample;
+	sp->v.loop_end = (lay->val[SF_endloopAddrsHi] << 16)
+		+ lay->val[SF_endloopAddrsHi]
+		+ sample->endloop - sp->startsample;
+	sp->v.data_length = sp->endsample;
+
+#if 0
+	if (sp->v.loop_start < 0)
+		fprintf(stderr, "negative loop pointer\n");
+	if (sp->v.loop_start > sp->v.loop_end)
+		fprintf(stderr, "illegal loop position\n");
+	if (sp->v.loop_end > sp->v.data_length)
+		fprintf(stderr, "illegal loop end or data size\n");
+#endif
+
+	sp->v.sample_rate = sample->samplerate;
+	if (lay->set[SF_keyRange]) {
+		sp->v.low_freq = freq_table[LO_VAL(lay->val[SF_keyRange])];
+		sp->v.high_freq = freq_table[HI_VAL(lay->val[SF_keyRange])];
+	} else {
+		sp->v.low_freq = freq_table[0];
+		sp->v.high_freq = freq_table[127];
+	}
+
+	/* scale tuning: 0  - 100 */
+	sp->v.scale_tuning = 100;
+	if (lay->set[SF_scaleTuning]) {
+		if (sf->version == 1)
+			sp->v.scale_tuning = lay->val[SF_scaleTuning] ? 50 : 100;
+		else
+			sp->v.scale_tuning = lay->val[SF_scaleTuning];
+	}
+
+	/* root pitch */
+	sp->v.root_freq = calc_root_pitch(lay, sf, sp);
+
+	sp->v.modes = MODES_16BIT;
+
+	/* volume envelope & total volume */
+	sp->v.volume = calc_volume(lay,sf);
+	if (lay->val[SF_sampleFlags] == 1 || lay->val[SF_sampleFlags] == 3) {
+		sp->v.modes |= MODES_LOOPING|MODES_SUSTAIN;
+#ifndef SF_SUPPRESS_ENVELOPE
+		convert_volume_envelope(lay, sf, sp);
+#endif
+		if (lay->val[SF_sampleFlags] == 3)
+			/* strip the tail */
+			sp->v.data_length = sp->v.loop_end + 1;
+	}
+
+	/* panning position: 0 to 127 */
+	sp->v.panning = 64;
+	if (lay->set[SF_panEffectsSend]) {
+		if (sf->version == 1)
+			sp->v.panning = (int8)lay->val[SF_panEffectsSend];
+		else
+			sp->v.panning = (int8)(((int)lay->val[SF_panEffectsSend] + 500) * 127 / 1000);
+	}
+
+	/* tremolo & vibrato */
+	sp->v.tremolo_sweep_increment = 0;
+	sp->v.tremolo_phase_increment = 0;
+	sp->v.tremolo_depth = 0;
+#ifndef SF_SUPPRESS_TREMOLO
+	convert_tremolo(lay, sf, sp);
+#endif
+	sp->v.vibrato_sweep_increment = 0;
+	sp->v.vibrato_control_ratio = 0;
+	sp->v.vibrato_depth = 0;
+#ifndef SF_SUPPRESS_VIBRATO
+	convert_vibrato(lay, sf, sp);
+#endif
+
+	/* set note to use for drum voices */
+	if (bank == 128)
+		sp->v.note_to_use = keynote;
+	else
+		sp->v.note_to_use = 0;
+
+	/* convert to fractional samples */
+	sp->v.data_length <<= FRACTION_BITS;
+	sp->v.loop_start <<= FRACTION_BITS;
+	sp->v.loop_end <<= FRACTION_BITS;
+
+	/* point to the file position */
+	sp->startsample = sp->startsample * 2 + sf->samplepos;
+	sp->endsample *= 2;
+
+	/* set cutoff frequency */
+	sp->cutoff_freq = 0;
+	if (lay->set[SF_initialFilterFc] || lay->set[SF_env1ToFilterFc])
+		calc_cutoff(lay, sf, sp);
+	if (lay->set[SF_initialFilterQ])
+		calc_filterQ(lay, sf, sp);
+}
+
+/* calculate root pitch */
+static int32 calc_root_pitch(Layer *lay, SFInfo *sf, SampleList *sp)
+{
+	int32 root, tune;
+	tsampleinfo *sample;
+
+	sample = &sf->sampleinfo[lay->val[SF_sampleId]];
+
+	root = sample->originalPitch;
+	tune = sample->pitchCorrection;
+	if (sf->version == 1) {
+		if (lay->set[SF_samplePitch]) {
+			root = lay->val[SF_samplePitch] / 100;
+			tune = -lay->val[SF_samplePitch] % 100;
+			if (tune <= -50) {
+				root++;
+				tune = 100 + tune;
+			}
+			if (sp->v.scale_tuning == 50)
+				tune /= 2;
+		}
+		/* orverride root key */
+		if (lay->set[SF_rootKey])
+			root += lay->val[SF_rootKey] - 60;
+		/* tuning */
+		tune += lay->val[SF_coarseTune] * sp->v.scale_tuning +
+			lay->val[SF_fineTune] * sp->v.scale_tuning / 100;
+	} else {
+		/* orverride root key */
+		if (lay->set[SF_rootKey])
+			root = lay->val[SF_rootKey];
+		/* tuning */
+		tune += lay->val[SF_coarseTune] * 100
+			+ lay->val[SF_fineTune];
+	}
+	/* it's too high.. */
+	if (lay->set[SF_keyRange] &&
+	    root >= HI_VAL(lay->val[SF_keyRange]) + 60)
+		root -= 60;
+
+	while (tune <= -100) {
+		root++;
+		tune += 100;
+	}
+	while (tune > 0) {
+		root--;
+		tune -= 100;
+	}
+	return (int32)((double)freq_table[root] * bend_fine[(-tune*255)/100]);
+}
+
+
+/*----------------------------------------------------------------
+ * convert volume envelope
+ *----------------------------------------------------------------*/
+
+static void convert_volume_envelope(Layer *lay, SFInfo *sf, SampleList *sp)
+{
+	int32 sustain = calc_sustain(lay, sf);
+	/*int delay = to_msec(lay, sf, SF_delayEnv2);*/
+	int32 attack = to_msec(lay, sf, SF_attackEnv2);
+	int32 hold = to_msec(lay, sf, SF_holdEnv2);
+	int32 decay = to_msec(lay, sf, SF_decayEnv2);
+	int32 release = to_msec(lay, sf, SF_releaseEnv2);
+
+	sp->v.envelope_offset[0] = to_offset(255);
+	sp->v.envelope_rate[0] = calc_rate(255, attack) * 2;
+
+	sp->v.envelope_offset[1] = to_offset(250);
+	sp->v.envelope_rate[1] = calc_rate(5, hold);
+	sp->v.envelope_offset[2] = to_offset(sustain);
+	sp->v.envelope_rate[2] = calc_rate(250 - sustain, decay);
+	sp->v.envelope_offset[3] = to_offset(5);
+	sp->v.envelope_rate[3] = calc_rate(255, release);
+	sp->v.envelope_offset[4] = to_offset(4);
+	sp->v.envelope_rate[4] = to_offset(200);
+	sp->v.envelope_offset[5] = to_offset(4);
+	sp->v.envelope_rate[5] = to_offset(200);
+
+	sp->v.modes |= MODES_ENVELOPE;
+}
+
+/* convert from 8bit value to fractional offset (15.15) */
+static int32 to_offset(int offset)
+{
+	return (int32)offset << (7+15);
+}
+
+/* calculate ramp rate in fractional unit;
+ * diff = 8bit, time = msec
+ */
+static int32 calc_rate(int diff, int time)
+{
+	int32 rate;
+
+	if (time < 6) time = 6;
+	if (diff == 0) diff = 255;
+	diff <<= (7+15);
+	rate = (diff / play_mode->rate) * control_ratio;
+	rate = rate * 1000 / time;
+	if (fast_decay) rate *= 2;
+
+	return rate;
+}
+
+
+#define TO_MSEC(tcents) (int32)(1000 * pow(2.0, (double)(tcents) / 1200.0))
+#define TO_MHZ(abscents) (int32)(8176.0 * pow(2.0,(double)(abscents)/1200.0))
+#define TO_HZ(abscents) (int32)(8.176 * pow(2.0,(double)(abscents)/1200.0))
+#define TO_LINEAR(centibel) pow(10.0, -(double)(centibel)/200.0)
+#define TO_VOLUME(centibel) (uint8)(255 * (1.0 - (centibel) / (1200.0 * log10(2.0))));
+
+/* convert the value to milisecs */
+static int32 to_msec(Layer *lay, SFInfo *sf, int index)
+{
+	int16 value;
+	if (! lay->set[index])
+		return 6;  /* 6msec minimum */
+	value = lay->val[index];
+	if (sf->version == 1)
+		return value;
+	else
+		return TO_MSEC(value);
+}
+
+/* convert peak volume to linear volume (0-255) */
+static float calc_volume(Layer *lay, SFInfo *sf)
+{
+	if (sf->version == 1)
+		return (float)(lay->val[SF_instVol] * 2) / 255.0;
+	else
+		return TO_LINEAR((double)lay->val[SF_instVol] / 10.0);
+}
+
+/* convert sustain volume to linear volume */
+static int32 calc_sustain(Layer *lay, SFInfo *sf)
+{
+	int32 level;
+	if (!lay->set[SF_sustainEnv2])
+		return 250;
+	level = lay->val[SF_sustainEnv2];
+	if (sf->version == 1) {
+		if (level < 96)
+			level = 1000 * (96 - level) / 96;
+		else
+			return 0;
+	}
+	return TO_VOLUME(level);
+}
+
+
+#ifndef SF_SUPPRESS_TREMOLO
+/*----------------------------------------------------------------
+ * tremolo (LFO1) conversion
+ *----------------------------------------------------------------*/
+
+static void convert_tremolo(Layer *lay, SFInfo *sf, SampleList *sp)
+{
+	int32 level, freq;
+
+	if (!lay->set[SF_lfo1ToVolume])
+		return;
+
+	level = lay->val[SF_lfo1ToVolume];
+	if (sf->version == 1)
+		level = (120 * level) / 64;  /* to centibel */
+	/* centibel to linear */
+	sp->v.tremolo_depth = TO_LINEAR(level);
+
+	/* frequency in mHz */
+	if (lay->set[SF_freqLfo1]) {
+		if (sf->version == 1)
+			freq = TO_MHZ(-725);
+		else
+			freq = 0;
+	} else {
+		freq = lay->val[SF_freqLfo1];
+		if (freq > 0 && sf->version == 1)
+			freq = (int)(3986.0 * log10((double)freq) - 7925.0);
+		freq = TO_MHZ(freq);
+	}
+	/* convert mHz to sine table increment; 1024<<rate_shift=1wave */
+	sp->v.tremolo_phase_increment = (freq * 1024) << RATE_SHIFT;
+
+	sp->v.tremolo_sweep_increment = 0;
+}
+#endif
+
+
+#ifndef SF_SUPPRESS_VIBRATO
+/*----------------------------------------------------------------
+ * vibrato (LFO2) conversion
+ *----------------------------------------------------------------*/
+
+static void convert_vibrato(Layer *lay, SFInfo *sf, SampleList *sp)
+{
+	int32 shift, freq;
+
+	if (!lay->set[SF_lfo2ToPitch])
+		return;
+
+	/* pitch shift in cents (= 1/100 semitone) */
+	shift = lay->val[SF_lfo2ToPitch];
+	if (sf->version == 1)
+		shift = (1200 * shift / 64 + 1) / 2;
+
+	/* cents to linear; 400cents = 256 */
+	sp->v.vibrato_depth = (int8)((int32)shift * 256 / 400);
+
+	/* frequency in mHz */
+	if (lay->set[SF_freqLfo2]) {
+		if (sf->version == 1)
+			freq = TO_MHZ(-725);
+		else
+			freq = 0;
+	} else {
+		freq = lay->val[SF_freqLfo2];
+		if (freq > 0 && sf->version == 1)
+			freq = (int)(3986.0 * log10((double)freq) - 7925.0);
+		freq = TO_MHZ(freq);
+	}
+	/* convert mHz to control ratio */
+	sp->v.vibrato_control_ratio = freq *
+		(VIBRATO_RATE_TUNING * play_mode->rate) /
+		(2 * VIBRATO_SAMPLE_INCREMENTS);
+
+	sp->v.vibrato_sweep_increment = 0;
+}
+#endif
+
+
+/* calculate cutoff/resonance frequency */
+static void calc_cutoff(Layer *lay, SFInfo *sf, SampleList *sp)
+{
+	int16 val;
+	if (! lay->set[SF_initialFilterFc]) {
+		val = 13500;
+	} else {
+		val = lay->val[SF_initialFilterFc];
+		if (sf->version == 1) {
+			if (val == 127)
+				val = 14400;
+			else if (val > 0)
+				val = 50 * val + 4366;
+		}
+	}
+	if (lay->set[SF_env1ToFilterFc]) {
+		val += lay->val[SF_env1ToFilterFc];
+	}
+	if (val >= 13500)
+		sp->cutoff_freq = 0;
+	else
+		sp->cutoff_freq = TO_HZ(val);
+}
+
+static void calc_filterQ(Layer *lay, SFInfo *sf, SampleList *sp)
+{
+	int16 val = lay->val[SF_initialFilterQ];
+	if (sf->version == 1)
+		val = val * 3 / 2; /* to centibels */
+	sp->resonance = pow(10.0, (double)val / 2.0 / 200.0) - 1;
+	if (sp->resonance < 0)
+		sp->resonance = 0;
+}
+
+
+#ifndef SF_SUPPRESS_CUTOFF
+/*----------------------------------------------------------------
+ * low-pass filter:
+ * 	y(n) = A * x(n) + B * y(n-1)
+ * 	A = 2.0 * pi * center
+ * 	B = exp(-A / frequency)
+ *----------------------------------------------------------------
+ * resonance filter:
+ *	y(n) = a * x(n) - b * y(n-1) - c * y(n-2)
+ *	c = exp(-2 * pi * width / rate)
+ *	b = -4 * c / (1+c) * cos(2 * pi * center / rate)
+ *	a = sqt(1-b*b/(4 * c)) * (1-c)
+ *----------------------------------------------------------------*/
+
+#ifdef LOOKUP_HACK
+#define MAX_DATAVAL 127
+#define MIN_DATAVAL -128
+#else
+#define MAX_DATAVAL 32767
+#define MIN_DATAVAL -32768
+#endif
+
+static void do_lowpass(Sample *sp, int32 freq, float resonance)
+{
+	double A, B, C;
+	sample_t *buf, pv1, pv2;
+	int32 i;
+
+	if (freq > sp->sample_rate * 2) {
+		ctl->cmsg(CMSG_ERROR, VERB_NORMAL,
+			  "Lowpass: center must be < data rate*2");
+		return;
+	}
+	A = 2.0 * M_PI * freq * 2.5 / sp->sample_rate;
+	B = exp(-A / sp->sample_rate);
+	A *= 0.8;
+	B *= 0.8;
+	C = 0;
+
+	/*
+	if (resonance) {
+		double a, b, c;
+		int32 width;
+		width = freq / 5;
+		c = exp(-2.0 * M_PI * width / sp->sample_rate);
+		b = -4.0 * c / (1+c) * cos(2.0 * M_PI * freq / sp->sample_rate);
+		a = sqrt(1 - b * b / (4 * c)) * (1 - c);
+		b = -b; c = -c;
+
+		A += a * resonance;
+		B += b;
+		C = c;
+	}
+	*/
+
+	pv1 = 0;
+	pv2 = 0;
+	buf = sp->data;
+	for (i = 0; i < sp->data_length; i++) {
+		sample_t l = *buf;
+		double d = A * l + B * pv1 + C * pv2;
+		if (d > MAX_DATAVAL)
+			d = MAX_DATAVAL;
+		else if (d < MIN_DATAVAL)
+			d = MIN_DATAVAL;
+		pv2 = pv1;
+		pv1 = *buf++ = (sample_t)d;
+	}
+}
+#endif
diff -ruN timidity-0.2i/sndfont.cfg timidity-0.2i+tr+sf/sndfont.cfg
--- timidity-0.2i/sndfont.cfg	Thu Jan  1 09:00:00 1970
+++ timidity-0.2i+tr+sf/sndfont.cfg	Wed Apr  2 21:24:08 1997
@@ -0,0 +1,19 @@
+#----------------------------------------------------------------
+# SoundFont extension configuration
+#
+# soundfont <filename> [order=<number>]
+#    filename is the path of SoundFont file.
+#    number is 0(preload) or 1(load after GUS).
+#
+# font exclude <bank> [<preset> [<keynote>]]
+# font order <number> <bank> [<preset> [<keynote>]]
+#----------------------------------------------------------------
+
+soundfont /usr/local/lib/sfbank/chaos4m.sf2
+
+# remove chaos drumset
+font exclude 128 99
+
+# load drum samples after GUS patches
+font order 1 128
+
diff -ruN timidity-0.2i/timidity.c timidity-0.2i+tr+sf/timidity.c
--- timidity-0.2i/timidity.c	Wed May 22 04:16:20 1996
+++ timidity-0.2i+tr+sf/timidity.c	Thu Apr  3 23:26:25 1997
@@ -279,6 +279,9 @@
   return 1;
 }
 
+char *sf_file = NULL;
+int sf_order = 0;
+
 #define MAXWORDS 10
 
 static int read_config_file(char *name)
@@ -387,6 +390,76 @@
 	    }
 	  bank=tonebank[i];
 	}
+      else if (!strcmp(w[0], "soundfont")) {
+	      if (words < 2) {
+		      fprintf(stderr, "%s: line %d: No soundfont file given\n", 
+			      name, line);
+		      return -2;
+	      }
+	      if (sf_file)
+		      free(sf_file);
+	      strcpy((sf_file=safe_malloc(strlen(w[1])+1)),w[1]);
+	      for (j = 2; j < words; j++) {
+		      if (!(cp = strchr(w[j], '='))) {
+			      fprintf(stderr, "%s: line %d: bad patch option %s\n",
+				      name, line, w[j]);
+			      return -2;
+		      }
+		      *cp++=0;
+		      if (!strcmp(w[j], "order")) {
+			      k = atoi(cp);
+			      if (k < 0 || (*cp < '0' || *cp > '9')) {
+				      fprintf(stderr,
+					      "%s: line %d: order must be a digit", name, line);
+				      return -2;
+			      }
+			      sf_order = k;
+		      }
+
+	      }
+      }
+      else if (!strcmp(w[0], "font")) {
+	      int bank, preset, keynote;
+	      if (words < 2) {
+		      fprintf(stderr, "%s: line %d: no font command\n", name, line);
+		      return -2;
+	      }
+	      if (!strcmp(w[1], "exclude")) {
+		      if (words < 3) {
+			      fprintf(stderr, "%s: line %d: No bank/preset/key is given\n", 
+				      name, line);
+			      return -2;
+		      }
+		      bank = atoi(w[2]);
+		      if (words >= 4)
+			      preset = atoi(w[3]);
+		      else
+			      preset = -1;
+		      if (words >= 5)
+			      keynote = atoi(w[4]);
+		      else
+			      keynote = -1;
+		      exclude_soundfont(bank, preset, keynote);
+	      } else if (!strcmp(w[1], "order")) {
+		      int order;
+		      if (words < 4) {
+			      fprintf(stderr, "%s: line %d: No order/bank is given\n", 
+				      name, line);
+			      return -2;
+		      }
+		      order = atoi(w[2]);
+		      bank = atoi(w[3]);
+		      if (words >= 5)
+			      preset = atoi(w[4]);
+		      else
+			      preset = -1;
+		      if (words >= 6)
+			      keynote = atoi(w[5]);
+		      else
+			      keynote = -1;
+		      order_soundfont(bank, preset, keynote, order);
+	      }
+      }
       else {
 	if ((words < 2) || (*w[0] < '0' || *w[0] > '9'))
 	  {
@@ -722,6 +795,9 @@
 	  else if (control_ratio > MAX_CONTROL_RATIO)
 		 control_ratio=MAX_CONTROL_RATIO;
 	}
+
+		if (sf_file)
+			init_soundfont(sf_file, sf_order);
 
 		if (*def_instr_name)
 	set_default_instrument(def_instr_name);
diff -ruN timidity-0.2i/tk_c.c timidity-0.2i+tr+sf/tk_c.c
--- timidity-0.2i/tk_c.c	Mon May 20 22:14:24 1996
+++ timidity-0.2i+tr+sf/tk_c.c	Fri Mar 21 17:29:43 1997
@@ -17,6 +17,12 @@
 #include <stdarg.h>
 #include <string.h>
 #include <sys/ioctl.h>
+#include <signal.h>
+#include <sys/ioctl.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#include <tcl.h>
+#include <tk.h>
 
 #include "config.h"
 #include "common.h"
@@ -44,6 +50,7 @@
 static int ctl_read(int32 *valp);
 static int cmsg(int type, int verbosity_level, char *fmt, ...);
 static void ctl_pass_playing_list(int number_of_files, char *list_of_files[]);
+static int ctl_blocking_read(int32 *valp);
 
 static void pipe_printf(char *fmt, ...);
 static void pipe_puts(char *str);
@@ -52,6 +59,46 @@
 static void pipe_error(char *st);
 static int pipe_read_ready();
 
+static int AppInit(Tcl_Interp *interp);
+static int ExitAll(ClientData clientData, Tcl_Interp *interp,
+		       int argc, char *argv[]);
+static int TraceCreate(ClientData clientData, Tcl_Interp *interp,
+		       int argc, char *argv[]);
+static int TraceUpdate(ClientData clientData, Tcl_Interp *interp,
+		    int argc, char *argv[]);
+static int TraceReset(ClientData clientData, Tcl_Interp *interp,
+		    int argc, char *argv[]);
+static void trace_volume(int ch, int val);
+static void trace_panning(int ch, int val);
+static void trace_prog_init(int ch);
+static void trace_prog(int ch, int val);
+static void trace_bank(int ch, int val);
+static void trace_sustain(int ch, int val);
+
+static void get_child(int sig);
+static void shm_alloc(void);
+static void shm_free(int sig);
+
+static void start_panel(void);
+
+#define MAX_MIDI_CHANNELS	16
+
+typedef struct {
+	int reset_panel;
+	int multi_part;
+
+	int32 last_time, cur_time;
+
+	char v_flags[MAX_MIDI_CHANNELS];
+	int16 cnote[MAX_MIDI_CHANNELS];
+	int16 cvel[MAX_MIDI_CHANNELS];
+	int16 ctotal[MAX_MIDI_CHANNELS];
+
+	char c_flags[MAX_MIDI_CHANNELS];
+	Channel channel[MAX_MIDI_CHANNELS];
+} PanelInfo;
+
+
 /**********************************************/
 
 #define ctl tk_control_mode
@@ -67,6 +114,22 @@
   ctl_expression, ctl_panning, ctl_sustain, ctl_pitch_bend
 };
 
+#define FLAG_NOTE_OFF	1
+#define FLAG_NOTE_ON	2
+
+#define FLAG_BANK	1
+#define FLAG_PROG	2
+#define FLAG_PAN	4
+#define FLAG_SUST	8
+
+static PanelInfo *Panel;
+
+static int shmid;	/* shared memory id */
+static int child_killed = 0;
+
+static int pipeAppli[2],pipePanel[2]; /* Pipe for communication with Tcl/Tk process   */
+static int fpip_in, fpip_out;	/* in and out depends in which process we are */
+static int child_pid;	               /* Pid for child process */
 
 
 /***********************************************************************/
@@ -75,7 +138,8 @@
 
 static int cmsg(int type, int verbosity_level, char *fmt, ...)
 {
-	char local[255];
+	char local[2048];
+#define TOO_LONG	2000
 
 	va_list ap;
 	if ((type==CMSG_TEXT || type==CMSG_INFO || type==CMSG_WARNING) &&
@@ -83,10 +147,20 @@
 		return 0;
 
 	va_start(ap, fmt);
+	if (strlen(fmt) > TOO_LONG)
+		fmt[TOO_LONG] = 0;
 	if (!ctl.opened) {
 		vfprintf(stderr, fmt, ap);
 		fprintf(stderr, "\n");
-	} else if (ctl.trace_playing) {
+	} else if (type == CMSG_ERROR) {
+		int rc;
+		int32 val;
+		vsprintf(local, fmt, ap);
+		pipe_printf("CERR %d", type);
+		pipe_puts(local);
+		while ((rc = ctl_blocking_read(&val)) != RC_NEXT)
+			;
+	} else {
 		vsprintf(local, fmt, ap);
 		pipe_printf("CMSG %d", type);
 		pipe_puts(local);
@@ -95,16 +169,8 @@
 	return 0;
 }
 
-
-static void _ctl_refresh(void)
-{
-	/* pipe_int_write(REFRESH_MESSAGE); */
-}
-
 static void ctl_refresh(void)
 {
-	if (ctl.trace_playing)
-		_ctl_refresh();
 }
 
 static void ctl_total_time(int tt)
@@ -125,137 +191,104 @@
 
 static void ctl_current_time(int ct)
 {
-	int i,v;
-	int centisecs=ct/(play_mode->rate/100);
+	Panel->cur_time = ct / (play_mode->rate/100) / 100;  /* sec order */
+}
 
-	if (!ctl.trace_playing) 
-		return;
-           
-	v=0;
-	i=voices;
-	while (i--)
-		if (voice[i].status!=VOICE_FREE) v++;
-    
-	pipe_printf("CURT %d %d", centisecs, v);
+
+static void ctl_channel_note(int ch, int note, int vel)
+{
+	if (vel == 0) {
+		if (note == Panel->cnote[ch])
+			Panel->v_flags[ch] = FLAG_NOTE_OFF;
+		Panel->cvel[ch] = 0;
+	} else if (vel > Panel->cvel[ch]) {
+		Panel->cvel[ch] = vel;
+		Panel->cnote[ch] = note;
+		Panel->ctotal[ch] = vel * Panel->channel[ch].volume *
+			Panel->channel[ch].expression / (127*127);
+		Panel->v_flags[ch] = FLAG_NOTE_ON;
+	}
 }
 
 static void ctl_note(int v)
 {
-    /*   int xl;
-    if (!ctl.trace_playing) 
-	return;
-    xl=voice[v].note%(COLS-24);
-    wmove(dftwin, 8+voice[v].channel,xl+3);
-    switch(voice[v].status)
-	{
-	case VOICE_DIE:
-	    waddch(dftwin, ',');
-	    break;
-	case VOICE_FREE: 
-	    waddch(dftwin, '.');
-	    break;
-	case VOICE_ON:
-	    wattron(dftwin, A_BOLD);
-	    waddch(dftwin, '0'+(10*voice[v].velocity)/128); 
-	    wattroff(dftwin, A_BOLD);
-	    break;
-	case VOICE_OFF:
-	case VOICE_SUSTAINED:
-	    waddch(dftwin, '0'+(10*voice[v].velocity)/128);
-	    break;
-	}
-	*/
+	int ch, note, vel;
+
+	if (!ctl.trace_playing) 
+		return;
+
+	ch = voice[v].channel;
+	if (ch < 0 || ch >= MAX_MIDI_CHANNELS) return;
+
+	note = voice[v].note;
+	if (voice[v].status != VOICE_ON)
+		vel = 0;
+	else
+		vel = voice[v].velocity;
+	ctl_channel_note(ch, note, vel);
 }
 
 static void ctl_program(int ch, int val)
 {
-/*  if (!ctl.trace_playing) 
-    return;
-  wmove(dftwin, 8+ch, COLS-20);
-  if (ISDRUMCHANNEL(ch))
-    {
-      wattron(dftwin, A_BOLD);
-      wprintw(dftwin, "%03d", val);
-      wattroff(dftwin, A_BOLD);
-    }
-  else
-    wprintw(dftwin, "%03d", val);
-    */
-}
-
-static void ctl_volume(int channel, int val)
-{
-    /*
-      if (!ctl.trace_playing) 
-    return;
-  wmove(dftwin, 8+channel, COLS-16);
-  wprintw(dftwin, "%3d", (val*100)/127);
-  */
-}
-
-static void ctl_expression(int channel, int val)
-{
-/*  if (!ctl.trace_playing) 
-    return;
-  wmove(dftwin, 8+channel, COLS-12);
-  wprintw(dftwin, "%3d", (val*100)/127);
-  */
+	if (!ctl.trace_playing) 
+		return;
+	if (ch < 0 || ch >= MAX_MIDI_CHANNELS) return;
+	Panel->channel[ch].program = val;
+	Panel->c_flags[ch] |= FLAG_PROG;
 }
 
-static void ctl_panning(int channel, int val)
+static void ctl_volume(int ch, int val)
 {
-/*  if (!ctl.trace_playing) 
-    return;
-  
-  if (val==NO_PANNING)
-    waddstr(dftwin, "   ");
-  else if (val<5)
-    waddstr(dftwin, " L ");
-  else if (val>123)
-    waddstr(dftwin, " R ");
-  else if (val>60 && val<68)
-    waddstr(dftwin, " C ");
-    */
-}
-
-static void ctl_sustain(int channel, int val)
-{
-/*
-  if (!ctl.trace_playing) 
-    return;
-
-  if (val) waddch(dftwin, 'S');
-  else waddch(dftwin, ' ');
-  */
+	if (!ctl.trace_playing)
+		return;
+	Panel->channel[ch].volume = val;
+	ctl_channel_note(ch, Panel->cnote[ch], Panel->cvel[ch]);
 }
 
-static void ctl_pitch_bend(int channel, int val)
+static void ctl_expression(int ch, int val)
+{
+	if (!ctl.trace_playing)
+		return;
+	Panel->channel[ch].expression = val;
+	ctl_channel_note(ch, Panel->cnote[ch], Panel->cvel[ch]);
+}
+
+static void ctl_panning(int ch, int val)
+{
+	if (!ctl.trace_playing) 
+		return;
+	Panel->channel[ch].panning = val;
+	Panel->c_flags[ch] |= FLAG_PAN;
+}
+
+static void ctl_sustain(int ch, int val)
 {
-/*  if (!ctl.trace_playing) 
-    return;
+	if (!ctl.trace_playing)
+		return;
+	Panel->channel[ch].sustain = val;
+	Panel->c_flags[ch] |= FLAG_SUST;
+}
 
-  if (val>0x2000) waddch(dftwin, '+');
-  else if (val<0x2000) waddch(dftwin, '-');
-  else waddch(dftwin, ' ');
-  */
+static void ctl_pitch_bend(int channel, int val)
+{
 }
 
 static void ctl_reset(void)
 {
-/*  int i,j;
-  if (!ctl.trace_playing) 
-    return;
-  for (i=0; i<16; i++)
-    {
-	ctl_program(i, channel[i].program);
-	ctl_volume(i, channel[i].volume);
-	ctl_expression(i, channel[i].expression);
-	ctl_panning(i, channel[i].panning);
-	ctl_sustain(i, channel[i].sustain);
-	ctl_pitch_bend(i, channel[i].pitchbend);
-    }
-  _ctl_refresh();
-  */
+	int i;
+
+	pipe_printf("RSET %d", ctl.trace_playing);
+	if (!ctl.trace_playing)
+		return;
+	for (i = 0; i < MAX_MIDI_CHANNELS; i++) {
+		ctl_program(i, channel[i].program);
+		ctl_volume(i, channel[i].volume);
+		ctl_expression(i, channel[i].expression);
+		ctl_panning(i, channel[i].panning);
+		ctl_sustain(i, channel[i].sustain);
+		ctl_pitch_bend(i, channel[i].pitchbend);
+		ctl_channel_note(i, Panel->cnote[i], 0);
+	}
 }
 
 /***********************************************************************/
@@ -263,12 +296,17 @@
 /***********************************************************************/
 static int ctl_open(int using_stdin, int using_stdout)
 {
-	ctl.opened=1;
-	ctl.trace_playing=1;	/* Default mode with Tcl/Tk interface */
-  
-	/* The child process won't come back from this call  */
+	shm_alloc();
 	pipe_open();
 
+	if (child_pid == 0)
+		start_panel();
+
+	signal(SIGCHLD, get_child);
+	signal(SIGTERM, shm_free);
+	signal(SIGINT, shm_free);
+
+	ctl.opened=1;
 	return 0;
 }
 
@@ -276,7 +314,8 @@
 static void ctl_close(void)
 {
 	if (ctl.opened) {
-		pipe_puts("QUIT");
+		kill(child_pid, SIGTERM);
+		shm_free(100);
 		ctl.opened=0;
 	}
 }
@@ -409,7 +448,8 @@
 			}
 			else if (command==RC_ERROR)
 				command=RC_TUNE_END; /* Launch next file */
-	    
+			else if (command==RC_CHANGE_VOLUME) /* init volume */
+				amplification += val;
 
 			switch(command)
 			{
@@ -433,46 +473,35 @@
 }
 
 
-/*
- */
-
-static int pipeAppli[2],pipePanel[2]; /* Pipe for communication with Tcl/Tk process   */
-static int fpip_in, fpip_out;	/* in and out depends in which process we are */
-static int pid;	               /* Pid for child process */
-
-static void pipe_open()
+/* open pipe and fork child process */
+static void pipe_open(void)
 {
 	int res;
-    
-	res=pipe(pipeAppli);
+
+	res = pipe(pipeAppli);
 	if (res!=0) pipe_error("PIPE_APPLI CREATION");
     
-	res=pipe(pipePanel);
+	res = pipe(pipePanel);
 	if (res!=0) pipe_error("PIPE_PANEL CREATION");
     
-	if ((pid=fork())==0)	/*child*/
-	{
+	if ((child_pid = fork()) == 0) {
+		/*child*/
 		close(pipePanel[1]); 
 		close(pipeAppli[0]);
 	    
+		/* redirect to stdin/out */
 		dup2(pipePanel[0], fileno(stdin));
 		close(pipePanel[0]);
 		dup2(pipeAppli[1], fileno(stdout));
 		close(pipeAppli[1]);
-	    
-		execlp(WISH, WISH, "-f", TKPROGPATH, NULL);
-		/* Won't come back from here */
-		fprintf(stderr,"WARNING: come back from TkMidity\n");
-		exit(0);
-	}
-    
-	close(pipePanel[0]);
-	close(pipeAppli[1]);
+	} else {
+		close(pipePanel[0]);
+		close(pipeAppli[1]);
     
-	fpip_in= pipeAppli[0];
-	fpip_out= pipePanel[1];
-}
-
+		fpip_in= pipeAppli[0];
+		fpip_out= pipePanel[1];
+	}
+}	    
 
 static int pipe_read_ready()
 {
@@ -530,5 +559,320 @@
 	}
 	*p = 0;
 	return len;
+}
+
+
+/*----------------------------------------------------------------
+ * shared memory handling
+ *----------------------------------------------------------------*/
+
+static void get_child(int sig)
+{
+	child_killed = 1;
+}
+
+static void shm_alloc(void)
+{
+	shmid = shmget(IPC_PRIVATE, sizeof(PanelInfo),
+		       IPC_CREAT|0600);
+	if (shmid < 0) {
+		fprintf(stderr, "can't allocate shared memory\n");
+		exit(1);
+	}
+	Panel = (PanelInfo *)shmat(shmid, 0, 0);
+	Panel->reset_panel = 0;
+	Panel->multi_part = 0;
+}
+
+static void shm_free(int sig)
+{ 
+	kill(child_pid, SIGTERM);
+	while (!child_killed)
+		;
+	shmctl(shmid, IPC_RMID,NULL);
+	shmdt((char *)Panel);
+	if (sig != 100)
+		exit(0);
+}
+
+/*----------------------------------------------------------------
+ * start Tk window panel
+ *----------------------------------------------------------------*/
+
+static void start_panel(void)
+{
+	char *argv[128];
+	int argc;
+    
+	argc = 0;
+	argv[argc++] = "-f";
+	argv[argc++] = TKPROGPATH;
+
+	if (ctl.trace_playing) {
+		argv[argc++] = "-mode";
+		argv[argc++] = "trace";
+	}
+
+	/* call Tk main routine */
+	Tk_Main(argc, argv, AppInit);
+
+	exit(0);
+}
+
+
+/*----------------------------------------------------------------
+ * initialize Tcl application
+ *----------------------------------------------------------------*/
+
+static Tcl_Interp *my_interp;
+
+static int AppInit(Tcl_Interp *interp)
+{
+	my_interp = interp;
+
+	if (Tcl_Init(interp) == TCL_ERROR) {
+		return TCL_ERROR;
+	}
+	if (Tk_Init(interp) == TCL_ERROR) {
+		return TCL_ERROR;
+	}
+
+	Tcl_CreateCommand(interp, "TraceCreate", TraceCreate,
+			  (ClientData)NULL, (Tcl_CmdDeleteProc*)NULL);
+	Tcl_CreateCommand(interp, "TraceUpdate", TraceUpdate,
+			  (ClientData)NULL, (Tcl_CmdDeleteProc*)NULL);
+	Tcl_CreateCommand(interp, "TraceReset", TraceReset,
+			  (ClientData)NULL, (Tcl_CmdDeleteProc*)NULL);
+	Tcl_CreateCommand(interp, "ExitAll", ExitAll,
+			  (ClientData)NULL, (Tcl_CmdDeleteProc*)NULL);
+	Tcl_CreateCommand(interp, "TraceUpdate", TraceUpdate,
+			  (ClientData)NULL, (Tcl_CmdDeleteProc*)NULL);
+	return TCL_OK;
+}
+
+static int ExitAll(ClientData clientData, Tcl_Interp *interp,
+		   int argc, char *argv[])
+{
+	/* window is killed; kill the parent process, too */
+	kill(getppid(), SIGTERM);
+	for (;;)
+		sleep(1000);
+}
+
+/* evaluate Tcl script */
+static char *v_eval(char *fmt, ...)
+{
+	char buf[256];
+	va_list ap;
+	va_start(ap, fmt);
+	vsprintf(buf, fmt, ap);
+	Tcl_Eval(my_interp, buf);
+	va_end(ap);
+	return my_interp->result;
+}
+
+static char *v_get2(char *v1, char *v2)
+{
+	return Tcl_GetVar2(my_interp, v1, v2, 0);
+}
+
+
+/*----------------------------------------------------------------
+ * update Tcl timer / trace window
+ *----------------------------------------------------------------*/
+
+#define FRAME_WIN	".body.trace"
+#define CANVAS_WIN	FRAME_WIN ".c"
+
+#define BAR_WID 20
+#define BAR_HGT 130
+#define WIN_WID (BAR_WID * 16)
+#define WIN_HGT (BAR_HGT + 11 + 17)
+#define BAR_HALF_HGT (WIN_HGT / 2 - 11 - 17)
+
+
+static int TraceCreate(ClientData clientData, Tcl_Interp *interp,
+		       int argc, char *argv[])
+{
+	int i;
+	v_eval("frame %s -bg black", FRAME_WIN);
+	v_eval("canvas %s -width %d -height %d -bd 0 -bg black "
+	       "-highlightthickness 0",
+	       CANVAS_WIN, WIN_WID, WIN_HGT);
+	v_eval("pack %s -side top -fill x", CANVAS_WIN);
+	for (i = 0; i < 32; i++) {
+		char *color;
+		v_eval("%s create text 0 0 -anchor n -fill white -text 00 "
+		       "-tags prog%d", CANVAS_WIN, i);
+		v_eval("%s create poly 0 0 0 0 0 0 -fill yellow -tags pos%d",
+		       CANVAS_WIN, i);
+		color = (i == 9 || i == 25) ? "red" : "green";
+		v_eval("%s create rect 0 0 0 0 -fill %s -tags bar%d "
+		       "-outline \"\"", CANVAS_WIN, color, i);
+	}
+	v_eval("set Stat(TimerId) -1");
+	v_eval("TraceReset");
+	return TCL_OK;
+}
+
+static void trace_bank(int ch, int val)
+{
+	v_eval("%s itemconfigure bar%d -fill %s",
+	       CANVAS_WIN, ch,
+	       (val == 128 ? "red" : "green"));
+}
+
+static void trace_prog(int ch, int val)
+{
+	v_eval("%s itemconfigure prog%d -text %02X",
+	       CANVAS_WIN, ch, val);
+}
+
+static void trace_sustain(int ch, int val)
+{
+	v_eval("%s itemconfigure prog%d -fill %s",
+	       CANVAS_WIN, ch,
+	       (val == 127 ? "green" : "white"));
+}
+
+static void trace_prog_init(int ch)
+{
+	int item, yofs, bar, x, y;
+
+	item = ch;
+	yofs = 0;
+	bar = Panel->multi_part ? BAR_HALF_HGT : BAR_HGT;
+	if (ch >= 16) {
+		ch -= 16;
+		yofs = WIN_HGT / 2;
+		if (!Panel->multi_part)
+			yofs = -500;
+	}
+	x = ch * BAR_WID + BAR_WID/2;
+	y = bar + 11 + yofs;
+	v_eval("%s coords prog%d %d %d", CANVAS_WIN, item, x, y);
+}
+
+static void trace_volume(int ch, int val)
+{
+	int item, bar, yofs, x1, y1, x2, y2;
+	item = ch;
+	yofs = 0;
+	bar = Panel->multi_part ? BAR_HALF_HGT : BAR_HGT;
+	if (ch >= 16) {
+		yofs = WIN_HGT / 2;
+		ch -= 16;
+		if (!Panel->multi_part)
+			yofs = -500;
+	}
+	x1 = ch * BAR_WID;
+	y1 = bar - 1 + yofs;
+	x2 = x1 + BAR_WID - 1;
+	y2 = y1 - bar * val / 127;
+	v_eval("%s coords bar%d %d %d %d %d", CANVAS_WIN,
+	       item, x1, y1, x2, y2);
+}
+
+static void trace_panning(int ch, int val)
+{
+	int item, bar, yofs;
+	int x, ap, bp;
+	if (val < 0) {
+		v_eval("%s coords pos%d -1 0 -1 0 -1 0", CANVAS_WIN, ch);
+		return;
+	}
+
+	item = ch;
+	yofs = 0;
+	bar = Panel->multi_part ? BAR_HALF_HGT : BAR_HGT;
+	if (ch >= 16) {
+		yofs = WIN_HGT / 2;
+		ch -= 16;
+		if (!Panel->multi_part)
+			yofs = -500;
+	}
+
+	x = BAR_WID * ch;
+	ap = BAR_WID * val / 127;
+	bp = BAR_WID - ap - 1;
+	v_eval("%s coords pos%d %d %d %d %d %d %d", CANVAS_WIN, item,
+	       ap + x, bar + 5 + yofs,
+	       bp + x, bar + 1 + yofs,
+	       bp + x, bar + 9 + yofs);
+}
+
+static int TraceReset(ClientData clientData, Tcl_Interp *interp,
+			   int argc, char *argv[])
+{
+	int i;
+	for (i = 0; i < 32; i++) {
+		trace_volume(i, 0);
+		trace_panning(i, -1);
+		trace_prog_init(i);
+		trace_prog(i, 0);
+		trace_sustain(i, 0);
+		Panel->ctotal[i] = 0;
+		Panel->cvel[i] = 0;
+		Panel->v_flags[i] = 0;
+		Panel->c_flags[i] = 0;
+	}
+
+	return TCL_OK;
+}
+
+
+
+#define DELTA_VEL	32
+
+static void update_notes(void)
+{
+	int i, imax;
+	imax = Panel->multi_part ? 32 : 16;
+	for (i = 0; i < imax; i++) {
+		if (Panel->v_flags[i]) {
+			if (Panel->v_flags[i] == FLAG_NOTE_OFF) {
+				Panel->ctotal[i] -= DELTA_VEL;
+				if (Panel->ctotal[i] <= 0) {
+					Panel->ctotal[i] = 0;
+					Panel->v_flags[i] = 0;
+				}
+			} else {
+				Panel->v_flags[i] = 0;
+			}
+			trace_volume(i, Panel->ctotal[i]);
+		}
+
+		if (Panel->c_flags[i]) {
+			if (Panel->c_flags[i] & FLAG_PAN)
+				trace_panning(i, Panel->channel[i].panning);
+			if (Panel->c_flags[i] & FLAG_BANK)
+				trace_bank(i, Panel->channel[i].bank);
+			if (Panel->c_flags[i] & FLAG_PROG)
+				trace_prog(i, Panel->channel[i].program);
+			if (Panel->c_flags[i] & FLAG_SUST)
+				trace_sustain(i, Panel->channel[i].sustain);
+			Panel->c_flags[i] = 0;
+		}
+	}
+}
+
+static int TraceUpdate(ClientData clientData, Tcl_Interp *interp,
+		    int argc, char *argv[])
+{
+	char *playing = v_get2("Stat", "Playing");
+	if (playing && *playing != '0') {
+		if (Panel->reset_panel) {
+			v_eval("TraceReset");
+			Panel->reset_panel = 0;
+		}
+		if (Panel->last_time != Panel->cur_time) {
+			v_eval("SetTime %d", Panel->cur_time);
+			Panel->last_time = Panel->cur_time;
+		}
+		if (ctl.trace_playing)
+			update_notes();
+	}
+	v_eval("set Stat(TimerId) [after 50 TraceUpdate]");
+	return TCL_OK;
 }
 
diff -ruN timidity-0.2i/tkbitmaps/back.xbm timidity-0.2i+tr+sf/tkbitmaps/back.xbm
--- timidity-0.2i/tkbitmaps/back.xbm	Thu Jan  1 09:00:00 1970
+++ timidity-0.2i+tr+sf/tkbitmaps/back.xbm	Mon Feb 17 16:38:37 1997
@@ -0,0 +1,9 @@
+#define back_width 22
+#define back_height 22
+static unsigned char back_bits[] = {
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x00, 0x00, 0xc3, 0x00,
+   0x80, 0xe3, 0x00, 0xc0, 0xf3, 0x00, 0xe0, 0xfb, 0x00, 0xe0, 0xfb, 0x00,
+   0xc0, 0xf3, 0x00, 0x80, 0xe3, 0x00, 0x00, 0xc3, 0x00, 0x00, 0x82, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
diff -ruN timidity-0.2i/tkbitmaps/fwrd.xbm timidity-0.2i+tr+sf/tkbitmaps/fwrd.xbm
--- timidity-0.2i/tkbitmaps/fwrd.xbm	Thu Jan  1 09:00:00 1970
+++ timidity-0.2i+tr+sf/tkbitmaps/fwrd.xbm	Mon Feb 17 16:38:37 1997
@@ -0,0 +1,9 @@
+#define fwrd_width 22
+#define fwrd_height 22
+static unsigned char fwrd_bits[] = {
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x10, 0x00, 0xc0, 0x30, 0x00,
+   0xc0, 0x71, 0x00, 0xc0, 0xf3, 0x00, 0xc0, 0xf7, 0x01, 0xc0, 0xf7, 0x01,
+   0xc0, 0xf3, 0x00, 0xc0, 0x71, 0x00, 0xc0, 0x30, 0x00, 0x40, 0x10, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
diff -ruN timidity-0.2i/tkbitmaps/next.xbm timidity-0.2i+tr+sf/tkbitmaps/next.xbm
--- timidity-0.2i/tkbitmaps/next.xbm	Fri Mar 29 18:19:49 1996
+++ timidity-0.2i+tr+sf/tkbitmaps/next.xbm	Mon Feb 17 16:38:38 1997
@@ -1,11 +1,9 @@
-#define next_width 30
+#define next_width 22
 #define next_height 22
 static unsigned char next_bits[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x04, 0x00, 0x30, 0x0c, 0x03,
+   0x70, 0x1c, 0x03, 0xf0, 0x3c, 0x03, 0xf0, 0x7d, 0x03, 0xf0, 0x7d, 0x03,
+   0xf0, 0x3c, 0x03, 0x70, 0x1c, 0x03, 0x30, 0x0c, 0x03, 0x10, 0x04, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x41, 0x00, 0x00, 0x00, 0xc3, 0x30, 0x00, 0x00, 0xc7, 0x31, 0x00,
-   0x00, 0xcf, 0x33, 0x00, 0x00, 0xdf, 0x37, 0x00, 0x00, 0xdf, 0x37, 0x00,
-   0x00, 0xcf, 0x33, 0x00, 0x00, 0xc7, 0x31, 0x00, 0x00, 0xc3, 0x30, 0x00,
-   0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00};
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
diff -ruN timidity-0.2i/tkbitmaps/pause.xbm timidity-0.2i+tr+sf/tkbitmaps/pause.xbm
--- timidity-0.2i/tkbitmaps/pause.xbm	Fri Mar 29 18:19:49 1996
+++ timidity-0.2i+tr+sf/tkbitmaps/pause.xbm	Mon Feb 17 16:38:38 1997
@@ -1,11 +1,9 @@
-#define pause_width 30
+#define pause_width 22
 #define pause_height 22
 static unsigned char pause_bits[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe3, 0x00, 0x80, 0xe3, 0x00,
+   0x80, 0xe3, 0x00, 0x80, 0xe3, 0x00, 0x80, 0xe3, 0x00, 0x80, 0xe3, 0x00,
+   0x80, 0xe3, 0x00, 0x80, 0xe3, 0x00, 0x80, 0xe3, 0x00, 0x80, 0xe3, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x1c, 0x07, 0x00, 0x00, 0x1c, 0x07, 0x00, 0x00, 0x1c, 0x07, 0x00,
-   0x00, 0x1c, 0x07, 0x00, 0x00, 0x1c, 0x07, 0x00, 0x00, 0x1c, 0x07, 0x00,
-   0x00, 0x1c, 0x07, 0x00, 0x00, 0x1c, 0x07, 0x00, 0x00, 0x1c, 0x07, 0x00,
-   0x00, 0x1c, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00};
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
diff -ruN timidity-0.2i/tkbitmaps/play.xbm timidity-0.2i+tr+sf/tkbitmaps/play.xbm
--- timidity-0.2i/tkbitmaps/play.xbm	Fri Mar 29 18:19:49 1996
+++ timidity-0.2i+tr+sf/tkbitmaps/play.xbm	Mon Feb 17 16:38:39 1997
@@ -1,11 +1,9 @@
-#define play_width 30
+#define play_width 22
 #define play_height 22
 static unsigned char play_bits[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0xc0, 0x03, 0x00,
+   0xc0, 0x0f, 0x00, 0xc0, 0x3f, 0x00, 0xc0, 0xff, 0x00, 0xc0, 0xff, 0x00,
+   0xc0, 0x3f, 0x00, 0xc0, 0x0f, 0x00, 0xc0, 0x03, 0x00, 0xc0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x0c, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00,
-   0x00, 0xfc, 0x03, 0x00, 0x00, 0xfc, 0x0f, 0x00, 0x00, 0xfc, 0x0f, 0x00,
-   0x00, 0xfc, 0x03, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00,
-   0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00};
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
diff -ruN timidity-0.2i/tkbitmaps/prev.xbm timidity-0.2i+tr+sf/tkbitmaps/prev.xbm
--- timidity-0.2i/tkbitmaps/prev.xbm	Fri Mar 29 18:19:49 1996
+++ timidity-0.2i+tr+sf/tkbitmaps/prev.xbm	Mon Feb 17 16:38:39 1997
@@ -1,11 +1,9 @@
-#define prev_width 30
+#define prev_width 22
 #define prev_height 22
 static unsigned char prev_bits[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x02, 0x30, 0x0c, 0x03,
+   0x30, 0x8e, 0x03, 0x30, 0xcf, 0x03, 0xb0, 0xef, 0x03, 0xb0, 0xef, 0x03,
+   0x30, 0xcf, 0x03, 0x30, 0x8e, 0x03, 0x30, 0x0c, 0x03, 0x00, 0x08, 0x02,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x80, 0x20, 0x00, 0x00, 0xc3, 0x30, 0x00, 0x00, 0xe3, 0x38, 0x00,
-   0x00, 0xf3, 0x3c, 0x00, 0x00, 0xfb, 0x3e, 0x00, 0x00, 0xfb, 0x3e, 0x00,
-   0x00, 0xf3, 0x3c, 0x00, 0x00, 0xe3, 0x38, 0x00, 0x00, 0xc3, 0x30, 0x00,
-   0x00, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00};
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
diff -ruN timidity-0.2i/tkbitmaps/quit.xbm timidity-0.2i+tr+sf/tkbitmaps/quit.xbm
--- timidity-0.2i/tkbitmaps/quit.xbm	Fri Mar 29 18:19:49 1996
+++ timidity-0.2i+tr+sf/tkbitmaps/quit.xbm	Mon Feb 17 16:38:39 1997
@@ -1,11 +1,9 @@
-#define quit_width 30
+#define quit_width 22
 #define quit_height 22
 static unsigned char quit_bits[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0xc0, 0x00, 0x00, 0x00, 0xe0, 0x01, 0x00, 0x00, 0xf0, 0x03, 0x00,
-   0x00, 0xf8, 0x07, 0x00, 0x00, 0xfc, 0x0f, 0x00, 0x00, 0xfe, 0x1f, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x1f, 0x00,
-   0x00, 0xfe, 0x1f, 0x00, 0x00, 0xfe, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00};
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x1e, 0x00,
+   0x00, 0x3f, 0x00, 0x80, 0x7f, 0x00, 0xc0, 0xff, 0x00, 0xe0, 0xff, 0x01,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0x01, 0xe0, 0xff, 0x01,
+   0xe0, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
diff -ruN timidity-0.2i/tkbitmaps/stop.xbm timidity-0.2i+tr+sf/tkbitmaps/stop.xbm
--- timidity-0.2i/tkbitmaps/stop.xbm	Fri Mar 29 18:19:49 1996
+++ timidity-0.2i+tr+sf/tkbitmaps/stop.xbm	Mon Feb 17 16:38:40 1997
@@ -1,11 +1,9 @@
-#define stop_width 30
+#define stop_width 22
 #define stop_height 22
 static unsigned char stop_bits[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x7f, 0x00,
+   0x80, 0x7f, 0x00, 0x80, 0x7f, 0x00, 0x80, 0x7f, 0x00, 0x80, 0x7f, 0x00,
+   0x80, 0x7f, 0x00, 0x80, 0x7f, 0x00, 0x80, 0x7f, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x07, 0x00, 0x00, 0xf8, 0x07, 0x00,
-   0x00, 0xf8, 0x07, 0x00, 0x00, 0xf8, 0x07, 0x00, 0x00, 0xf8, 0x07, 0x00,
-   0x00, 0xf8, 0x07, 0x00, 0x00, 0xf8, 0x07, 0x00, 0x00, 0xf8, 0x07, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-   0x00, 0x00, 0x00, 0x00};
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
diff -ruN timidity-0.2i/tkbitmaps/timidity.xbm timidity-0.2i+tr+sf/tkbitmaps/timidity.xbm
--- timidity-0.2i/tkbitmaps/timidity.xbm	Thu Jan  1 09:00:00 1970
+++ timidity-0.2i+tr+sf/tkbitmaps/timidity.xbm	Mon Feb 17 16:38:40 1997
@@ -0,0 +1,42 @@
+#define timidity_width 87
+#define timidity_height 52
+static char timidity_bits[] = {
+ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7e,0x00,
+ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0xff,0x00,0x00,0x00,0x00,0x00,
+ 0x00,0x00,0x00,0x00,0xfe,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+ 0xff,0xc1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x1f,0xc0,0x00,0x00,
+ 0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x01,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,
+ 0x00,0x00,0xc0,0x00,0xc0,0x00,0x00,0x00,0xfe,0xff,0x00,0x00,0x00,0xc0,0x00,
+ 0xc0,0x00,0x00,0x00,0xfe,0xff,0x00,0x00,0x00,0xc0,0x00,0xc0,0x00,0x00,0x00,
+ 0xfe,0xff,0x00,0x00,0x00,0xc0,0x00,0xc0,0x00,0x00,0x00,0x80,0x03,0x00,0x00,
+ 0x70,0x80,0x01,0xc0,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
+ 0xff,0xff,0x7f,0x80,0x03,0x00,0x00,0x70,0x80,0x01,0xc0,0x01,0x00,0x00,0x80,
+ 0x03,0x00,0x00,0x00,0x00,0x03,0xf8,0xff,0x00,0x00,0x80,0x03,0x00,0x00,0x00,
+ 0x00,0x03,0xfc,0xff,0x01,0x00,0x80,0x03,0x00,0x00,0x20,0x00,0x03,0xf0,0xff,
+ 0x00,0x00,0x80,0x03,0x07,0x00,0x70,0x00,0x03,0x00,0x03,0x00,0x00,0xff,0xff,
+ 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,0x80,0x03,0x07,0x00,0x70,0x00,
+ 0x03,0x00,0x03,0x00,0x00,0x80,0x03,0x00,0x00,0x70,0x00,0x03,0x00,0x03,0x00,
+ 0x00,0x80,0x03,0xc0,0x00,0x72,0xf0,0x03,0xe0,0x03,0x00,0x0f,0x80,0x03,0xc2,
+ 0x01,0x73,0xf8,0x03,0xf0,0x83,0x83,0x07,0x80,0x03,0xc7,0x83,0x73,0xfc,0xe3,
+ 0xf8,0x87,0x83,0x03,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,
+ 0x80,0x03,0xc7,0xef,0x73,0xfc,0xe3,0xf8,0x87,0x83,0x03,0x00,0x00,0xc7,0xfd,
+ 0x23,0xfc,0x03,0xf8,0x07,0x87,0x03,0x00,0x00,0xc7,0xb9,0x03,0xf8,0x01,0xf0,
+ 0x03,0xcf,0x03,0x00,0x00,0xc7,0x91,0x03,0xf0,0x40,0xe0,0x01,0xde,0x01,0x00,
+ 0x00,0xc7,0x81,0x03,0x00,0xe0,0x00,0x00,0xf8,0x01,0xff,0xff,0xff,0xff,0xff,
+ 0xff,0xff,0xff,0xff,0xff,0x7f,0x00,0x00,0xc2,0x81,0x03,0x00,0xe0,0x00,0x00,
+ 0xf0,0x00,0x00,0x00,0xc0,0x81,0x03,0x00,0xe0,0x00,0x00,0xf0,0x00,0x00,0x00,
+ 0xc0,0x81,0x03,0x00,0xe0,0x00,0x00,0x70,0x00,0x00,0x00,0xc0,0x81,0x03,0x00,
+ 0xe0,0x00,0x00,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x00,0x00,0x38,
+ 0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,0x00,0x00,0x00,
+ 0x00,0x00,0x00,0x40,0x00,0x06,0x1e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+ 0x00,0x86,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x07,0x00,
+ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x01,0x00,0x00,0x00,0x00,0x00,
+ 0x00,0x00,0x00,0x00,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+ 0x00,0x00};
diff -ruN timidity-0.2i/tkmidity.ptcl timidity-0.2i+tr+sf/tkmidity.ptcl
--- timidity-0.2i/tkmidity.ptcl	Fri Mar 29 18:19:49 1996
+++ timidity-0.2i+tr+sf/tkmidity.ptcl	Mon Feb 17 16:40:44 1997
@@ -16,15 +16,23 @@
 lappend auto_path $TclRoot
 
 #
+# window fonts
+#
+
+option add *menu*font "-adobe-helvetica-bold-r-normal--12-*"
+option add *body.curfile.font "-adobe-helvetica-bold-o-normal--17-*"
+option add *body.file*font "-adobe-helvetica-medium-r-normal--14-*"
+option add *body*label.font "-adobe-times-bold-i-normal--17-*"
+option add *body*Scale.font "-adobe-times-medium-i-normal--14-*"
+option add *body.text*font "-adobe-helvetica-medium-r-normal--14-*"
+
+#
 # main routine
 #
 
 InitGlobal
 LoadConfig
-
-wm title . "TkMidity"
-wm iconname . "TkMidity"
-wm iconbitmap . @$bitmap_path/timidity.xbm
+InitCmdLine $argc $argv
 
 CreateWindow
 AppendMsg "TiMidity Tcl/Tk Version\n  written by Takashi Iwai\n"
diff -ruN timidity-0.2i/tkpanel.tcl timidity-0.2i+tr+sf/tkpanel.tcl
--- timidity-0.2i/tkpanel.tcl	Fri Mar 29 18:19:50 1996
+++ timidity-0.2i+tr+sf/tkpanel.tcl	Fri Mar 21 17:33:46 1997
@@ -26,7 +26,6 @@
     set Stat(MaxSecs) 0
     set Stat(LastSec) 0
     set Stat(TotalTimeStr) "/ 0:00"
-    set Stat(CurVol) 100
 
     # message lines
     set Stat(CurMsgs) 0
@@ -42,13 +41,17 @@
     set Stat(MaxFiles) 0
     set Stat(FileList) {}
     set Stat(ShuffleList) {}
+    set Stat(CurFile) "--------"
+    set Stat(NextFile) "--------"
 
     global Config
     # playing mode
+    set Config(Tracing) 0
     set Config(RepeatPlay) 0
     set Config(ShufflePlay) 0
     set Config(AutoStart) 0
     set Config(AutoExit) 0
+    set Config(ConfirmExit) 1
 
     # display configuration
     set Config(Disp:file) 1
@@ -56,6 +59,17 @@
     set Config(Disp:text) 1
     set Config(Disp:volume) 1
     set Config(Disp:button) 1
+    set Config(Disp:trace) 1
+
+    set Config(CurFileMode) 0
+
+    # current volume
+    set Config(CurVol) 100
+
+    wm title . "TkAWEMidi"
+    wm iconname . "TkAWEMidi"
+    global bitmap_path
+    wm iconbitmap . @$bitmap_path/timidity.xbm
 }
 
 
@@ -68,7 +82,11 @@
     set mlist [gets stdin]
     set msg [lindex $mlist 0]
 
-    if {$msg == "TIME"} {
+    if {$msg == "RSET"} {
+	if {$Config(Tracing)} {
+	    TraceReset
+	}
+    } elseif {$msg == "TIME"} {
 	# set total time
 	set csecs [expr [lindex $mlist 1] / 100]
 	set mins [expr $csecs / 60]
@@ -86,11 +104,14 @@
 
     } elseif {$msg == "FILE"} {
 	# set playing file
-	set path [lindex $mlist 1]
-	set divs [split $path /]
-	set file [lindex $divs [expr [llength $divs] - 1]]
-	wm title . "TkMidity: $file"
-	wm iconname . "TkMidity: $file"
+	set Stat(CurFile) [retrieve-filename [lindex $mlist 1]]
+	wm title . "TkAWEMidi: $Stat(CurFile)"
+	wm iconname . "TkAWEMidi: $Stat(CurFile)"
+	if {$Config(CurFileMode) == 0} {
+	    .body.curfile configure -text "$Stat(CurFile) / 00:00"
+	} else {
+	    .body.curfile configure -text "$Stat(CurFile) / -$Stat(TotalTimeStr)"
+	}
 	AppendMsg "------"
 
     } elseif {$msg == "LIST"} {
@@ -103,7 +124,7 @@
 	    .body.file.list insert end $file
 	    lappend Stat(FileList) $file
 	}
-	MakeShuffleList
+	# MakeShuffleList
 
 	set Stat(CurIdx) -1
 	SelectNumber 
@@ -128,16 +149,16 @@
 	}
 	SelectNumber
 
-    } elseif {$msg == "CURT"} {
-	# set current time
-	SetTime [expr [lindex $mlist 1] / 100]
-
     } elseif {$msg == "CMSG"} {
 	# put message
 	set type [lindex $mlist 1]
 	set str [gets stdin]
 	AppendMsg $str
 
+    } elseif {$msg == "CERR"} {
+	error [format "%s: %s" $Stat(NextFile) [gets stdin]]
+	WriteMsg "NEXT"
+
     } elseif {$msg == "QUIT"} {
 	# quit
 	exit
@@ -163,7 +184,6 @@
 	set pos [my-random $len]
 	lappend Stat(ShuffleList) [lindex $tmplist $pos]
 	set tmplist [lreplace $tmplist $pos $pos]
-	lappend Stat(ShuffleList) [lindex $tmplist $pos]
 	set len [expr $len - 1]
     }
 }
@@ -204,11 +224,15 @@
     set idx -1
     if {$Stat(CurIdx) >= 0 && $Stat(CurIdx) < [llength $Stat(FileList)]} {
 	if {$Config(ShufflePlay)} {
+	    if {$Stat(ShuffleList) == {}} {
+		MakeShuffleList
+	    }
 	    set idx [lindex $Stat(ShuffleList) $Stat(CurIdx)]
 	} else {
 	    set idx $Stat(CurIdx)
 	}
 	set thefile [lindex $Stat(FileList) $idx]
+	set Stat(NextFile) $thefile
     }
     if {$idx >= 0 && ![file exists $thefile]} {
 	warning "Can't open file \"$thefile\"."
@@ -228,7 +252,7 @@
 	set Stat(Playing) 1
     } else {
 	SetTime 0
-	.body.curfile configure -text "Playing:"
+	.body.curfile configure -text "-------- / 00:00"
 	set Stat(Playing) 0
 	set Stat(Paused) 0
     }
@@ -240,16 +264,25 @@
 # update current time
 #
 proc SetTime {val} {
-    global Stat
-    if {$val != $Stat(LastSec)} {
-	set Stat(LastSec) $val
-	set mins [expr $val / 60]
-	set secs [expr $val % 60]
-	.body.time.label configure\
-		-text [format "%d:%02d %s" $mins $secs $Stat(TotalTimeStr)]
-	.body.time.scale set $val
-	DispButtonPlay
+    global Stat Config
+    if {$Stat(CurIdx) == -1} {
+	return
     }
+    set Stat(LastSec) $val
+    if {$Config(CurFileMode) == 0} {
+	set curt [sec2time $val]
+	.body.curfile configure\
+		-text "$Stat(CurFile) / $curt"
+    } else {
+	set curt [sec2time [expr $val - $Stat(MaxSecs)]]
+	.body.curfile configure\
+		-text "$Stat(CurFile) / $curt"
+    }
+    set curt [sec2time $val]
+    .body.time.label configure\
+	    -text "$curt / $Stat(TotalTimeStr)"
+    .body.time.scale set $val
+    DispButtonPlay
 }
 
 
@@ -283,9 +316,8 @@
 # update current volume
 #
 proc SetVolume {val} {
-    global Stat
-    set Stat(CurVol) $val
-    .body.volume.label configure -text [format "Volume: %d%%" $val]
+    global Config
+    set Config(CurVol) $val
     .body.volume.scale set $val
 }
 
@@ -319,11 +351,11 @@
 #
 # change volume amplitude
 #
-proc VolumeCmd {val} {
-    global Stat
+proc VolumeCmd {val {force 0}} {
+    global Config
     if {$val < 0} {set val 0}
     if {$val > 200} {set val 200}
-    if {$val != $Stat(CurVol)} {
+    if {$force != 0 || $val != $Config(CurVol)} {
 	WriteMsg [format "VOLM %d" $val]
     }
 }
@@ -332,9 +364,11 @@
 # load the specified file
 #
 proc LoadCmd {idx} {
-    global Stat
+    global Stat Config
     WriteMsg "LOAD"
     WriteMsg [lindex $Stat(FileList) $idx]
+    AppendMsg ""
+    VolumeCmd $Config(CurVol) 1
 }
 
 #
@@ -367,12 +401,17 @@
 # stop playing
 #
 proc StopCmd {} {
-    global Stat
+    global Stat Config
     if {$Stat(Playing)} {
 	WriteMsg "QUIT"
 	WriteMsg "XTND"
 	set Stat(CurIdx) -1
 	SelectNumber
+	if {$Config(Tracing)} {
+	    TraceReset
+	}
+	wm title . "TkAWEMidi"
+	wm iconname . "TkAWEMidi"
     }
 }
 
@@ -381,9 +420,14 @@
 #
 proc QuitCmd {} {
     global Config Stat
+    if {$Config(AutoExit) || !$Config(ConfirmExit)} {
+	WriteMsg "QUIT"
+	WriteMsg "ZAPP"
+	return
+    }
     set oldpause $Stat(Paused)
     if {!$oldpause} {PauseCmd}
-    if {$Config(AutoExit) || [question "Really Quit TkMidity?" 0]} {
+    if {[question "Really Quit TkMidity?" 0]} {
 	WriteMsg "QUIT"
 	WriteMsg "ZAPP"
 	return
@@ -411,17 +455,38 @@
     }
 }
 
-proc VolUpCmd {} {
+#
+# forward/backward 2 secs
+#
+proc ForwardCmd {} {
     global Stat
     if {$Stat(Playing)} {
-	VolumeCmd [expr $Stat(CurVol) + 10]
+	WriteMsg "FWRD"
+    }
+}
+    
+proc BackwardCmd {} {
+    global Stat
+    if {$Stat(Playing)} {
+	WriteMsg "BACK"
+    }
+}
+
+
+#
+# volume up/down
+#
+proc VolUpCmd {} {
+    global Stat Config
+    if {$Stat(Playing)} {
+	VolumeCmd [expr $Config(CurVol) + 5]
     }
 }
 
 proc VolDownCmd {} {
-    global Stat
+    global Stat Config
     if {$Stat(Playing)} {
-	VolumeCmd [expr $Stat(CurVol) - 10]
+	VolumeCmd [expr $Config(CurVol) - 5]
     }
 }
 
@@ -430,7 +495,7 @@
 #
 proc DispTables {} {
     global Config
-    set allitems {file time text volume button}
+    set allitems {file time text volume button trace}
 
     foreach i $allitems {
 	pack forget .body.$i
@@ -459,18 +524,54 @@
 # load configuration file
 #
 proc LoadConfig {} {
-    global ConfigFile
+    global ConfigFile Stat
     catch {source $ConfigFile}
 }
 
 #
+# from command line
+#
+proc InitCmdLine {argc argv} {
+    global Config
+    set Config(Disp:trace) 0
+    for {set i 0} {$i < $argc} {incr i} {
+	if {[lindex $argv $i] == "-mode"} {
+	    incr i
+	    set mode [lindex $argv $i]
+	    if {$mode == "trace"} {
+		set Config(Tracing) 1
+		set Config(Disp:trace) 1
+	    } elseif {$mode == "shuffle"} {
+		set Config(ShufflePlay) 1
+	    } elseif {$mode == "normal"} {
+		set Config(ShufflePlay) 0
+	    } elseif {$mode == "autostart"} {
+		set Config(AutoStart) 1
+	    } elseif {$mode == "autoexit"} {
+		set Config(AutoExit) 1
+	    } elseif {$mode == "repeat"} {
+		set Config(RepeatPlay) 1
+	    }
+	}
+    }
+}
+
+
+#
 # selection callback of the playing file from listbox
 #
 proc SelectList {lw pos} {
-    global Stat
+    global Config Stat
     set idx [$lw nearest $pos]
     if {$idx >= 0 && $idx < $Stat(MaxFiles)} {
-	set Stat(CurIdx) $idx
+	if {$Config(ShufflePlay)} {
+	    set found [lsearch -exact $Stat(ShuffleList) $idx]
+	    if {$found != -1} {
+		set Stat(CurIdx) $found
+	    }
+	} else {
+	    set Stat(CurIdx) $idx
+	}
 	set Stat(Playing) 1
 	SelectNumber
     }
@@ -489,7 +590,7 @@
 	    .body.file.list insert end $i
 	    lappend Stat(FileList) $i
 	}
-	MakeShuffleList
+	# MakeShuffleList
     }
 }
 
@@ -507,6 +608,16 @@
     }
 }
 
+proc ToggleCurFileMode {} {
+    global Config Stat
+    if {$Config(CurFileMode) == 0} {
+	set Config(CurFileMode) 1
+    } else {
+	set Config(CurFileMode) 0
+    }
+    SetTime $Stat(LastSec)
+}
+
 #----------------
 # create main window
 #
@@ -542,14 +653,18 @@
     .menu.mode.m add check -label "Repeat" -underline 0\
 	    -variable Config(RepeatPlay)
     .menu.mode.m add check -label "Shuffle" -underline 0\
-	    -variable Config(ShufflePlay) -command "MakeShuffleList"
+	    -variable Config(ShufflePlay) -command {
+	if {$Config(ShufflePlay)} {MakeShuffleList}
+    }
     .menu.mode.m add check -label "Auto Start" -underline 5\
 	    -variable Config(AutoStart)
     .menu.mode.m add check -label "Auto Exit" -underline 5\
 	    -variable Config(AutoExit)
+    .menu.mode.m add check -label "Confirm Quit" -underline 0\
+	    -variable Config(ConfirmExit)
 
-    # Displays menu
-    menubutton .menu.disp -text "Displays" -menu .menu.disp.m\
+    # Display menu
+    menubutton .menu.disp -text "Display" -menu .menu.disp.m\
 	    -underline 0
     menu .menu.disp.m
     .menu.disp.m add check -label "File List" -underline 0\
@@ -562,6 +677,10 @@
 	    -variable Config(Disp:volume) -command "DispTables"
     .menu.disp.m add check -label "Buttons" -underline 0\
 	    -variable Config(Disp:button) -command "DispTables"
+    if {$Config(Tracing)} {
+	.menu.disp.m add check -label "Trace" -underline 1\
+		-variable Config(Disp:trace) -command "DispTables"
+    }
 
     pack .menu.file .menu.mode .menu.disp -side left
 
@@ -574,7 +693,8 @@
     pack .body -side top -expand 1 -fill both
 
     # current playing file
-    label .body.curfile -text "Playing:" -relief ridge
+    button .body.curfile -text "-------- / 00:00" -relief ridge\
+	    -command "ToggleCurFileMode"
     pack .body.curfile -side top -expand 1 -fill x
 
     # playing files list
@@ -583,10 +703,10 @@
 	    -command ".body.file.list yview"
     pack .body.file.bar -side right -fill y
     if {$Stat(new_tcltk)} {
-	listbox .body.file.list -width 40 -height 10 -relief sunken -bd 2\
+	listbox .body.file.list -width 36 -height 10 -relief sunken -bd 2\
 		-yscroll ".body.file.bar set"
     } else {
-	listbox .body.file.list -geometry 40x10 -relief sunken -bd 2\
+	listbox .body.file.list -geometry 36x10 -relief sunken -bd 2\
 		-yscroll ".body.file.bar set"
     }
     bind .body.file.list <Button-1> {SelectList %W %y}
@@ -607,7 +727,7 @@
     scrollbar .body.text.bar -relief sunken\
 	    -command ".body.text.buf yview"
     pack .body.text.bar -side right -fill y
-    text .body.text.buf -width 40 -height 12 -relief sunken -bd 2\
+    text .body.text.buf -width 36 -height 12 -relief sunken -bd 2\
 	    -wrap word -yscroll ".body.text.bar set"
     bind .body.text.buf <Button-1> { }
     bind .body.text.buf <Any-Key> { }
@@ -621,8 +741,9 @@
     label .body.volume.label -text "Volume:"
     pack .body.volume.label -side top
     scale .body.volume.scale -orient horizontal -length 280\
-	    -from 0 -to 200 -tickinterval 25
-    bind .body.volume.scale <ButtonRelease-1> {VolumeCmd [%W get]}
+	    -from 0 -to 200 -tickinterval 25\
+	    -showvalue true -label "Volume"\
+	    -command VolumeCmd
     pack .body.volume.scale -side bottom -expand 1 -fill x
 
     # buttons
@@ -634,25 +755,37 @@
 	    -command "StopCmd"
     button .body.button.prev -bitmap @$bitmap_path/prev.xbm\
 	    -command "PrevCmd"
+    button .body.button.back -bitmap @$bitmap_path/back.xbm\
+	    -command "BackwardCmd"
+    button .body.button.fwrd -bitmap @$bitmap_path/fwrd.xbm\
+	    -command "ForwardCmd"
     button .body.button.next -bitmap @$bitmap_path/next.xbm\
 	    -command "NextCmd"
     button .body.button.pause -bitmap @$bitmap_path/pause.xbm\
 	    -command "PauseCmd"
     button .body.button.quit -bitmap @$bitmap_path/quit.xbm\
 	    -command "QuitCmd"
-    pack .body.button.play .body.button.stop\
-	    .body.button.prev .body.button.next\
-	    .body.button.pause .body.button.quit\
-	    -side left -padx 5 -pady 5
+    pack .body.button.play .body.button.pause\
+	    .body.button.prev .body.button.back\
+	    .body.button.stop\
+	    .body.button.fwrd .body.button.next\
+	    .body.button.quit\
+	    -side left -ipadx 4 -pady 2 -fill x
+
+    if {$Config(Tracing)} {
+	# trace display
+	TraceCreate
+    }
+    TraceUpdate
 
     # pack all items
     DispTables
 
     focus .
     tk_menuBar .menu .menu.file .menu.mode .menu.disp
-    bind . <Key-Right> "NextCmd"
+    bind . <Key-Right> "ForwardCmd"
     bind . <Key-n> "NextCmd"
-    bind . <Key-Left> "PrevCmd"
+    bind . <Key-Left> "BackwardCmd"
     bind . <Key-p> "PrevCmd"
     bind . <Key-s> "PauseCmd"
     bind . <Key-Down> "VolDownCmd"
@@ -663,4 +796,6 @@
     bind . <Return> "PlayCmd"
     bind . <Key-c> "StopCmd"
     bind . <Key-q> "QuitCmd"
+
+    VolumeCmd $Config(CurVol) 1
 }
